### 5.事务隔离级别
> 第一种隔离级别：Read uncommitted(读未提交)            
> 如果一个事务已经开始写数据，则另外一个事务不允许同时进行写操作，但允许其他事务读此行数据，该隔离级别可以通过“排他写锁”，但是不排斥读线程实现。
> 这样就避免了更新丢失，却可能出现脏读，也就是说事务B读取到了事务A未提交的数据。          
> 读未提交解决了数据更新丢失，但可能会出现脏读。脏读就是一个事务在处理过程中读取了另外一个事务未提交的数据。             
  这种未提交的数据称之为脏数据。依据脏数据所做的操作肯能是不正确的。  
>                         
> 第二种隔离级别：Read committed(读已提交)           
> 如果是一个读事务(线程)，则允许其他事务读写，如果是写事务将会禁止其他事务访问该行数据，该隔离级别避免了脏读，但是可能出现不可重复读。
> 事务A事先读取了数据，事务B紧接着更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。         
> 解决了更新丢失和脏读问题,但可能会出现不可重复读。不可重复读是指一个事务范围内，多次查询某个数据，却得到不同的结果。
> 在第一个事务中的两次读取数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能就是不一样的。
>                        
> 第三种隔离级别：Repeatable read(可重复读取)            
> 可重复读取是指在一个事务内，多次读同一个数据，在这个事务还没结束时，其他事务不能访问该数据(包括了读写)，
> 这样就可以在同一个事务内两次读到的数据是一样的。读取数据的事务将会禁止写事务(但允许读事务)，写事务则禁止任何其他事务(包括了读写)。               
> 解决了更新丢失、脏读问题和不可重复读，但可能会出现幻读。          
> 幻读是事务非独立执行时发生的一种现象。               
  例如事务A对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务B又对这个表中插入了一行数据项为“1”的数据，并且提交给数据库。
  而操作事务A的用户如果再查看刚刚修改的数据，会发现数据怎么还是1？其实这行是从事务B中添加的，就好像产生幻觉一样，这就是发生了幻读。 
>                                      
> 第四种隔离级别：Serializable(可序化)         
> 提供严格的事务隔离，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行，如果仅仅通过“行级锁”是无法实现序列化的，
> 必须通过其他机制保证新插入的数据不会被执行查询操作的事务访问到。序列化是最高的事务隔离级别，同时代价也是最高的，性能很低，一般很少使用，
> 在该级别下，事务顺序执行，不仅可以避免脏读、不可重复读，还避免了幻读。  
  ![mysql1](http://github.com/xidianlina/practice/raw/master//mysql_practice/picture/mysql1.png)        
> 脏读、不可重复读和幻读，其实都是数据库读一致性问题，必须由数据库提供一定的事务隔离机制来解决。               
> 数据库实现事务隔离的方式，基本上可分为以下两种：              
  一种是在读取数据前，对其加锁，阻止其他事务对数据进行修改。             
  另一种是不用加任何锁，通过一定机制生成一个数据请求时间点的一致性数据快照（Snapshot)，并用这个快照来提供一定级别（语句级或事务级）的一致性读取。从用户的角度来看，好像是数据库可以提供同一数据的多个版本，因此，这种技术叫做数据多版本并发控制（MultiVersion Concurrency Control，简称MVCC或MCC），也经常称为多版本数据库。             
  数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上 “串行化”进行，这显然与“并发”是矛盾的。同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读”和“幻读”并不敏感，可能更关心数据并发访问的能力。          
>               
> 脏读是某一事务读取了另外一个事务未提交的数据，不可重复读是读取了其他事务提交的数据。            
  幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。                
  不可重复读重点在于update和delete，而幻读的重点在于insert。避免不可重复读需要锁行（某一行在select操作时，不允许update与delete）就行，避免幻读则需要锁表。
> 如果使用锁机制来实现这两种隔离级别，在可重复读中，该sql第一次读取到数据后，就将这些数据加锁，其它事务无法修改这些数据，就可以实现可重复读了。但这种方法却无法锁住insert的数据，所以当事务A先前读取了数据，或者修改了全部数据，事务B还是可以insert数据提交，这时事务A就会发现莫名其妙多了一条之前没有的数据，幻读不能通过行锁来避免，需要Serializable隔离级别 ，读用读锁，写用写锁，读锁和写锁互斥，这么做可以有效的避免幻读、不可重复读、脏读等问题，但会极大的降低数据库的并发能力。所以说不可重复读和幻读最大的区别，就在于如何通过锁机制来解决他们产生的问题。          
>                   
> 在MYSQL数据库中，支持上面四种隔离级别，默认的为Repeatable read(可重复读)。              
> 隔离级别越高，越能保证数据的完整性和统一性，但是执行效率就越低，对并发性能的影响也越大。像Serializable这样的级别，就是以锁表的方式（类似于Java多线程中的锁）使得其他的线程只能在锁外等待，所以平时选用何种隔离级别应该根据实际情况。                    
  Oracle仅仅实现了RC和SERIALIZABLE隔离级别。默认采用RC隔离级别，解决了脏读。但是允许不可重复读和幻读。其SERIALIZABLE则解决了脏读、不可重复读、幻读。                
> MySQL支持全部4个隔离级别，但在具体实现时，有一些特点，比如在一些隔离级别下是采用MVCC一致性读，但某些情况下又不是。MySQL默认采用RR隔离级别，SQL标准是要求RR解决不可重复读的问题，但是因为MySQL通过nex-key lock在RR隔离级别下解决了幻读的问题。MySQL的SERIALIZABLE采用了经典的实现方式，对读和写都加锁。              
>                       
> 隔离级别的实现               
> 事务的机制是通过视图（read-view）来实现的并发版本控制（MVCC），不同的事务隔离级别创建读视图的时间点不同。               
  读未提交是不创建，直接返回记录上的最新值。                                       
  可重复读是每个事务重建读视图，整个事务存在期间都用这个视图。                                         
> 读已提交是每条SQL创建读视图，在每个SQL语句开始执行的时候创建的。隔离作用域仅限该条SQL语句。                          
  串行化隔离级别下直接用加锁的方式来避免并行访问。                      
  视图可以理解为数据副本，每次创建视图时，将当前已持久化的数据创建副本，后续直接从副本读取，从而达到数据隔离效果。             
> ![mysql2](http://github.com/xidianlina/practice/raw/master//mysql_practice/picture/mysql2.png)            
>           
> 参考 http://blog.itpub.net/31559358/viewspace-2221403/                                    
