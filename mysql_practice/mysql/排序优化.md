### 22.order by排序优化
> 尽可能使用索引字段来排序，性能最佳。                                
> 双路排序              
  MySQL4.1之前的版本，通过两次扫描磁盘，最终得到数据             
  先从磁盘中读取行指针和order by列，并对它们进行排序，然后扫描已经排好序的列表，按照列表中的值重新从列表中读出（再一次从磁盘中读），要对磁盘进行两次扫描，I\O是很耗时的。                                  
  单路排序              
  MySQL4.1之后，增加的更优排序算法              
  从磁盘读取查询需要的所有列，按照order by列在buffer（缓冲区）对它们进行排序，然后扫描排序后的列表进行输出,它的效率要更快一些，
>避免了第二次读取数据（从磁盘读）并且把随机I\O变成了顺序I\O,但是它会使用过多空间，因为它把每一行都保存在内存中了。                
  不足：               
  在sort_buffer中，单路算法比双路算法要多占用很多空间               
  因为单路算法是把所有字段都取出，所以有可能取出的数据总大小超出了sort_buffer（MySQL会给每个线程分配一块内存用于排序）的容量，
  导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取出,sort_buffer容量太小，再排......从而多次I\O操作,本想着省一次I\O操作，反而导致了大量的I\O操作，反而得不偿失。                
  使用单路排序满足的条件：              
  (1).查询语句所取出的字段类型大小总和要小于 max_length_for_sort_data              
  (2).排序字段中不包含text和blob类型               
  优化策略              
  order by时，只query需要的字段         
  (1).当query的字段大小总和小于max_length_for_sort_data，而且排序字段不是TEXT｜BLOB类型，会使用单路排序算法，否则使用多路排序算法              
  (2).两种算法的数据都有可能超出sort_buffer的容量，超出之后，创建tmp文件进行合并排序，导致多次的I\O，但是使用单路排序的风险更大，所以要提高sort_buffer_size               
  尝试提高sort_buffer_size              
  不管使用哪种算法，提高这个参数都会提高效率             
  要根据系统的自身能力去提高，因为这个参数是针对每个进程的          
  尝试提高max_length_for_sort_data          
  提高这个参数，会增加用改进算法的概率。               
  但如果设置得太高，数据总容量超出sort_buffer_size的概率会增大，明显症状是高的磁盘I\O活动和低的处理器使用率                            
>
> 参考 https://segmentfault.com/a/1190000021478171 
