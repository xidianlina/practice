## 10.Redis是怎么持久化的？
>Redis有两种持久化方式:RDB和AOF。RDB做镜像全量持久化，AOF做增量持久化。               
 RDB在指定的时间间隔内将内存中的数据集快照（Snapshot快照）写入磁盘，它恢复时是将快照文件直接读到内存里。              
 redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。           
 Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。                    
>                   
>配置位置:              
 save 900 1         
 save 300 10            
 save 60 10000          
 RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件。默认 ：1分钟内改了1万次； 5分钟内改了10次；15分钟内改了1次。           
>                               
>禁用:如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以               
>                           
>如何触发RDB快照:                     
 save或bgsave命令会触发rdb快照。                     
 save时只管保存，其它不管，全部阻塞;使用bgsave命令时redis会在后台异步进行快照操作，快照同时还可以响应客户端请求。                
 可以通过lastsave命令获取最后一次成功执行快照的时间。                 
 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。                    
 如何恢复：将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。               
 config get dir获取目录                 
>                       
>优势:                    
 适合大规模的数据恢复                 
 单独创建（fork）一个子进程来进行持久化，父进程不需要做其他IO操作，RDB方式可以最大化redis的性能                 
 对数据完整性和一致性要求不高                 
 劣势:                
 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改；                  
 Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。                 
 停止rdb快照:                   
 动态停止RDB保存规则的方法：redis-cli config set save ""                                
>                           
>AOF以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)。只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据。                    
 redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作              
 aof保存的是appendonly.aof文件                
>                           
>配置位置:                  
 appendonly no                  
 appendfilename "appendonly.aof"                
>                       
>appendfsync:                   
 always:同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好               
 everysec:出厂默认推荐，异步操作，每秒记录 如果一秒内宕机，有数据丢失                    
 no：从不同步                
>                                              
>aof的启动、修复、恢复：                      
 正常恢复：                  
 修改默认的appendonly no，改为yes即启动aof持久化；             
 将有数据的aof文件复制一份保存到对应目录(config get dir)；                 
 重启redis然后重新加载appendonly.aof文件，完成恢复。            
 异常恢复：              
 修改默认的appendonly no，改为yes即启动aof持久化；             
 备份appendonly.aof文件；                
 运行redis-check-aof --fix appendonly.aof命令进行数据修复；                                
 重启redis然后重新加载appendonly.aof文件，完成恢复。   
>                                        
>rewrite:                         
 aof采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当aof文件的大小超过所设定的阈值时，redis就会启动aof文件的内容压缩，只保留可以恢复数据的最小指令集.               
 命令bgrewriteaof用于手动触发重写操作。即使bgrewriteaof执行失败，也不会有任何数据丢失，因为旧的aof文件在bgrewriteaof成功之前不会被修改。                
 重写原理:aof文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的set语句。             
 重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。                    
 触发机制:redis会记录上次重写时的aof大小，默认配置是当aof文件大小是上次rewrite后大小的一倍且文件大于64M时触发。                     
>                           
>优势：                
 每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好         
 每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失              
 不同步：appendfsync no 从不同步                    
 劣势：aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同
>                                       
>rdb和aof持久化选择哪一个？               
 只做缓存时可以不使用任何持久化方式。                 
 rdb文件只用作后备用途，建议只在slave上持久化rdb文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。             
 同时开启两种持久化方式：                   
 在这种情况下,当redis重启的时候会优先载入aof文件来恢复原始的数据,因为在通常情况下aof文件保存的数据集要比RDB文件保存的数据集要完整。
 rdb的数据不实时，同时使用两者时服务器重启也只会找aof文件。那要不要只使用aof呢？建议不要，因为rdb更适合用于备份数据库(aof在不断变化不好备份)，
 快速重启，而且不会有aof可能潜在的bug，留着作为一个万一的手段。                     
