## 35.一致性Hash
>对服务器数量取模方式实现的hash算法来进行缓存数据定位时，redis服务器数量变动时，所有缓存的位置都会发生改变。为了规避这个情况，Hash一致性算法就诞生了。                      
 一致性的Hash算法是对2的32方取模。即，一致性Hash算法将整个Hash空间组织成一个虚拟的圆环，Hash函数的值空间为0 ~ 2^32 - 1(一个32位无符号整型)。                    
>               
>首先求出服务器节点的哈希值，并将其配置到0～2^32的圆环上。                
 然后采用同样的方法求出存储数据的键的哈希值，并映射到相同的圆上。                   
 然后从数据映射到的位置开始顺时针查找，将数据保存到找到的第一个服务器上。如果超过232仍然找不到服务器，就会保存到第一台服务器上。                  
>           
>一致性Hash算法的容错性和可扩展性                 
 在一致性Hash算法中，如果一台服务器不可用，受影响的数据仅仅是此服务器到其环空间前一台服务器之间的数据，其他不会受到影响。         
 一致性哈希算法对于节点的增减都只需重定位环空间中的一小部分数据，具有较好的容错性和可扩展性。                 
>                   
>数据倾斜问题：                            
 一致性哈希算法在服务节点太少时，容易因为节点分部不均匀而造成数据倾斜问题。被缓存的对象大部分缓存在某一台服务器上。                  
 为了解决数据倾斜问题，一致性Hash算法引入了虚拟节点机制，即对每一个服务器节点计算多个哈希，每个计算结果位置都放置一个此服务节点，称为虚拟节点。                       
 数据定位算法不变，只需要增加一步：虚拟节点到实际点的映射。                                 
 所以加入虚拟节点之后，即使在服务节点很少的情况下，也能做到数据的均匀分布。      
>               
>如何判定哈希算法               ：
 (1).平衡性(Balance)：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，使得所有的缓冲空间都得到利用。             
>               
>(2).单调性(Monotonicity)：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。
>哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。               
>           
>(3).分散性(Spread)：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。
>当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，
>最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，
>降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。                                    
>                   
>(4).负载(Load)：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，
>那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。                  
 (5).平滑性(Smoothness)：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。                                             
 