## 12.Redis的同步机制？
>为了避免服务的单点故障，会把数据复制到多个副本放在不同的服务器上，且这些拥有数据副本的服务器可以用于处理客户端的读请求，扩展整体的性能。           
 Redis支持主从复制，Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制分为全量同步和增量同步。             
>               
>全量同步                             
 Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：               
 (1).从服务器连接主服务器，发送SYNC命令；               
 (2).主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；              
 (3).主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；                
 (4).从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；                
 (5).主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；              
 (6).从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；                
> ![redis](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis.png)              
>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。                
>               
>增量同步                                  
 Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。                                 
 增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。             
>               
>主从复制的特点：               
 (1).采用异步复制；                    
 (2).一个主redis可以含有多个从redis；              
 (3).每个从redis可以接收来自其他从redis服务器的连接；          
 (4).主从复制对于主redis服务器来说是非阻塞的，这意味着当从服务器在进行主从复制同步过程中，主redis仍然可以处理外界的访问请求；              
 (5).主从复制对于从redis服务器来说也是非阻塞的，这意味着，即使从redis在进行主从复制过程中也可以接受外界的查询请求，
>只不过这时候从redis返回的是以前老的数据，如果你不想这样，那么在启动redis时，可以在配置文件中进行设置，那么从redis
>在复制同步过程中来自外界的查询请求都会返回错误给客户端；（虽然说主从复制过程中对于从redis是非阻塞的，但是当从redis
>从主redis同步过来最新的数据后还需要将新数据加载到内存中，在加载到内存的过程中是阻塞的，在这段时间内的请求将会被阻，
>但是即使对于大数据集，加载到内存的时间也是比较多的）；                    
 (6).主从复制提高了redis服务的扩展性，避免单个redis服务器的读写访问压力过大的问题，同时也可以给为数据备份及冗余提供一种解决方案；                
 (7).为了减少主redis服务器写磁盘压力带来的开销，可以配置让主redis不在将数据持久化到磁盘，而是通过连接让一个配置的从redis服务器及时的将相关
>数据持久化到磁盘，不过这样会存在一个问题，就是主redis服务器一旦重启，因为主redis服务器数据为空，这时候通过主从同步可能导致从redis服务器上的数据也被清空。               
>                               
>部分同步:              
 从redis 2.8版本以前，并不支持部分同步，当主从服务器之间的连接断掉之后，master服务器和slave服务器之间都是进行全量数据同步，
>但是从redis 2.8开始，即使主从连接中途断掉，也不需要进行全量同步。部分同步的实现依赖于在master服务器内存中给每个slave服务器
>维护了一份同步日志和同步标识，每个slave服务器在跟master服务器进行同步时都会携带自己的同步标识和上次同步的最后位置。当主从连
>接断掉之后，slave服务器隔断时间（默认1s）主动尝试和master服务器进行连接，如果从服务器携带的偏移量标识还在master服务器上的
>同步备份日志中，那么就从slave发送的偏移量开始继续上次的同步操作，如果slave发送的偏移量已经不再master的同步备份日志中（可能
>由于主从之间断掉的时间比较长或者在断掉的短暂时间内master服务器接收到大量的写操作），则必须进行一次全量更新。在部分同步过程中，
>master会将本地记录的同步备份日志中记录的指令依次发送给slave服务器从而达到数据一致。                    
>               
>主从复制的好处：                   
 数据冗余，实现数据的热备份                  
 故障恢复，避免单点故障带来的服务不可用                
 读写分离，负载均衡。主节点负责读写，从节点负责读，提高服务器并发量              
 高可用基础，是哨兵机制和集群实现的基础                                  
>                                          
>一主多从:一个master可以有多个slave            
>查看机器主从复制情况的命令：info replication                                        
>slaveof ip port                
 问:切入点问题：slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1、k2、k3是否也可以复制？          
 答:从头开始复制                     
 问:从机是否可以写？set可否？             
 答:从机不可写              
 问:主机shutdown后情况如何？从机是上位还是原地待命？               
 答:原地待命               
 问:主机又回来了后，主机新增记录，从机还能否顺利复制？              
 答:能              
 问:其中一台从机down后情况如何？依照原有它能跟上大部队吗？                  
 答:不能，每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件。               
>                                   
>级联结构(薪火相传)                     
>上一个slave可以是下一个slave的master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。                  
 中途变更转向:会清除之前的数据，重新建立拷贝最新的。slaveof 新主库IP 新主库端口                  
>                   
>哨兵模式(sentinel)                 
>哨兵模式是一种特殊的模式，它是Redis高可用的一种实现方案。哨兵是一个独立的Redis服务端进程， 可以实现对Redis实例的监控、通知、自动故障转移、配置提供。                                   
>监控(Monitoring)：哨兵(sentinel) 会不断地检查你的 Master 和 Slave 是否运作正常。                
 提醒(Notification)：当被监控的某个 Redis 出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。          
 自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,
>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master; 当客户端试图连接失效的
>Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。                             
>配置提供（Configuration provider）：客户端可以把 Sentinel 作为权威的配置发布者来获得最新的master地址。如果发生了故障转移，
>Sentinel集群会通知客户端新的 master 地址，并刷新 Redis 的配置。       
>               
>定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：通过向主从节点发送info命令获取最新的主从结构；
>通过发布订阅功能获取其他哨兵节点的信息；通过向其他节点发送ping命令进行心跳检测，判断是否下线。                  
 主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。
>顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。           
 客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；
>如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。             
 需要特别注意的是，客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。         
 选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。
 监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请
>，如果B没有同意过其他哨兵，则会同意A成为领导者。一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。            
 故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤：                           
 在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；
>如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。
 更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。       
>           
>Sentinel缺陷:            
 Sentinel模式下，写操作仍然只能在Sentinel提供的master数据节点上执行，无法负载均衡                
 持久化时master节点刷盘阻塞，服务请求成功率下降             
 slave节点存储能力受到单机的限制         
 分区问题:原master redis3断开与redis1和redis2的连接，此时redis1和redis2执行故障转移，选择redis1为master。
>这时，redis1和redis3都能接受写请求，但数据无法同步，数据不一致。                                                                               
