## 20.使用redis的缺点?
>(1).缓存和数据库双写一致性问题
>一致性问题分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。如果对数据有强一致性要求，就不能放缓存。
>数据库和缓存双写只能保证最终一致性。其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。   
>                                                                                                  
>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，
>对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。                   
>                       
>为保证redis和数据库双写一致性问题，首先采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。                         
>                       
>先更新数据库，再更新缓存是普遍反对的。                    
 两点原因:                  
 原因一（线程安全角度）                    
 同时有请求A和请求B进行更新操作，那么会出现                 
 a.线程A更新了数据库                    
 b.线程B更新了数据库                
 c.线程B更新了缓存             
 d.线程A更新了缓存                     
 这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。                 
 原因二（业务场景角度）                    
 a.如果是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。                
 b.如果写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。                    
>                               
>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。                
>先删缓存，再更新数据库导致不一致的原因是:同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:                    
 a.请求A进行写操作，删除缓存                
 b.请求B查询发现缓存不存在         
 c.请求B去数据库查询得到旧值            
 d.请求B将旧值写入缓存           
 e.请求A将新值写入数据库                  
 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。               
>                   
>如何解决呢？             
 采用延时双删策略               
 a.先淘汰缓存                
 b.再写数据库（这和原来一样）                
 c.休眠1秒，再次淘汰缓存              
 这么做，可以将1秒内所造成的缓存脏数据，再次删除。              
 这个1秒怎么确定的，具体该休眠多久呢？                    
 针对上面的情形，开发者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。
>这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。                   
 如果用了mysql的读写分离架构造成数据不一致的原因如下：还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。              
 a.请求A进行写操作，删除缓存                    
 b.请求A将数据写入数据库了                     
 c.请求B查询缓存发现，缓存没有值                  
 d.请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值                  
 e.请求B将旧值写入缓存               
 f.数据库完成主从同步，从库变为新值             
 上述情形还是使用双删延时策略。只是睡眠时间修改为在主从同步的延时时间基础上，加几百ms。           
>                   
>采用这种同步淘汰策略，吞吐量降低怎么办？                   
 将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。             
 第二次删除,如果删除失败怎么办？               
 这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：                      
 a.请求A进行写操作，删除缓存                        
 b.请求B查询发现缓存不存在                     
 c.请求B去数据库查询得到旧值                        
 d.请求B将旧值写入缓存                   
 e.请求A将新值写入数据库              
 f.请求A试图去删除请求B写入对缓存值，结果失败了。                     
>                   
>如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。                             
 如何解决呢？                     
 提供一个保障的重试机制:                   
 a.更新数据库数据；                     
 b.缓存因为种种问题删除失败                 
 c.将需要删除的key发送至消息队列             
 d.自己消费消息，获得需要删除的key                
 e.继续重试删除操作，直到成功
> ![redis2](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis2.png)              
>该方案有一个缺点，对业务线代码造成大量的侵入。                    
 于是有了方案二:启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。              
> ![redis3](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis3.png)              
>流程如下：              
 a.更新数据库数据              
 b.数据库会将操作信息写入binlog日志当中                
 c.订阅程序提取出所需要的数据以及key               
 d.另起一段非业务代码，获得该信息              
 e.尝试删除缓存操作，发现删除失败              
 f.将这些信息发送至消息队列             
 g.重新从消息队列中获得该数据，重试操作               
 订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能
>                               
>先更新数据库，再删缓存                    
>先删缓存，再更新数据库导致不一致的原因是:假设这会有两个请求，一个请求A做查询操作，一个请求B做更新操作，那么会有如下情形产生:               
 a.缓存刚好失效               
 b.请求A查询数据库，得一个旧值               
 c.请求B将新值写入数据库              
 d.请求B删除缓存              
 e.请求A将查到的旧值写入缓存                
 如果发生上述情况，确实是会发生脏数据。                
>                   
>发生上述情况有一个先天性条件，就是步骤c的写数据库操作比步骤b的读数据库操作耗时更短，才有可能使得步骤d先于步骤e。         
 数据库的读操作的速度远快于写操作的，因此步骤c耗时比步骤b更短，这一情形很难出现。          
 所以，先更新数据库，再删缓存虽然还会有问题，但是，问题出现的可能性会比较低。             
>在大多数情况下，在不想做过多设计，增加太大工作量的情况下，请先更新数据库，再删缓存!                     

> 参考 https://www.cnblogs.com/rjzheng/p/9041659.html                                                                                           
>                                                                                     
>(2).缓存穿透问题
>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。
>如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。                     
 解决方法：              
 a.将无效的key存放进Redis中：                        
 当出现Redis查不到数据，数据库也查不到数据的情况，就把这个key保存到Redis中，设置value="null"，并设置其过期时间极短，后面再出现查询这个key
>的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。                        
 b.使用布隆过滤器：                 
 如果布隆过滤器判定某个key不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。
>于是可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询key是否存在，
>如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。 
> ![redis4](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis4.png)              
>如何选择：                          
 针对一些恶意攻击，攻击带过来的大量key是随机，那么采用a方案就会缓存大量不存在key的数据。那么这种方案就不合适了，
>可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。
>而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。                         
>                   
>(3).缓存雪崩问题
>如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的请求打在了数据库上，导致数据库压力巨大，如果在高并发的情况下，
>可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。             
 造成缓存雪崩的关键在于同一时间的大规模的key失效，为什么会出现这个问题，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同的过期时间。                    
 解决方案：              
 [1].事前：                
 a.均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。              
 b.分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。               
 c. 热点数据缓存永远不过期。                
 永不过期实际包含两层意思：                  
 物理不过期，针对热点key不设置过期时间                   
 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建           
 d.保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。           
 [2].事中：            
 a.互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，
>其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降                    
 b.使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，
>至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。                 
 [3].事后：                            
 开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。                                                
>                                      
>(4).缓存击穿问题                 
>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，
>就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。                   
 关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。                   
 解决方案：                  
 a.热点数据缓存永远不过期。                 
 b.在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降。               
> 参考 https://blog.csdn.net/a745233700/article/details/88088669                                 
>                                   
>(5).如何解决redis的并发竞争key问题(有多个子系统去set一个key)                               
[1].如果对这个key操作不要求顺序,则准备一个分布式锁，多个子系统去抢锁，抢到锁就做set操作即可。                                                
[2].如果对这个key操作要求顺序。假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC。               
期望按照key1的value值按照 valueA-->valueB-->valueC的顺序变化。                                                     
a.利用队列，将set方法变成串行访问。                                                                       
b.保存一个时间戳。假设时间戳如下:                                      
系统A key1 {valueA  3:00}                                                      
系统B key1 {valueB  3:05}                                            
系统C key1 {valueC  3:10}                                                    
那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。                                     
>                       
>乐观锁不要在分片集群中使用 
