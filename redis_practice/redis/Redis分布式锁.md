## 4.Redis分布式锁?redis分布式锁有什么缺陷？
>在系统中修改已有数据时，需要先读取，然后进行修改保存，此时很容易遇到并发问题。由于修改和保存不是原子操作，在并发场景下，部分对数据的操作可能会丢失。
>在单服务器系统常用本地锁来避免并发带来的问题，然而，当服务采用集群方式部署时，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。                  
 使用分布式锁有两个场景:                   
 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。            
 正确性:加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。         
>               
>分布式锁特点:            
 互斥性:和本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。             
 可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。             
 锁超时:和本地锁一样支持锁超时，防止死锁。              
 高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。                
 支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。            
 支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。       
>               
>常见的分布式锁：           
 (1).基于MySQL中的锁：                
 [1].利用主键唯一规则：在争抢锁的时候向DB中写一条记录，这条记录主要包含锁的id、当前占用锁的线程名、重入的次数和创建时间等，
>如果插入成功表示当前线程获取到了锁，如果插入失败那么证明锁被其他人占用，等待一会儿继续争抢，直到争抢到或者超时为止。         
 优点：实现简单                
 缺点：没有超时保护机制，mysql存在单点，并发量大的时候请求量太大、没有线程唤醒机制。           
 [2].利用Mysql行锁的特性：Mysql是有表锁、页锁和行锁的机制的，可以利用这个机制来实现锁。这里尽量使用行锁，它的吞吐量是最高的。          
 利用for update加显式的行锁，这样就能利用这个行级的排他锁来实现分布式锁了，同时unlock的时候只要释放commit这个事务，就能达到释放锁的目的。            
 优点：实现简单                
 缺点：连接池爆满和事务超时的单点问题，行锁升级为表锁的问题，并发量大的时候请求量太大、没有线程唤醒机制。               
 利用事务进行加锁的时候，query需要占用数据库连接，在行锁的时候连接不释放，这就会导致连接池爆满。同时由于事务是有超时时间的，过了超时时间自动回滚，会导致锁的释放，这个超时时间要把控好。             
 行锁升级为表锁的问题：Mysql行锁默认需要走索引，如果不走索引会导致锁表，如果可以，在sql中可以强制指定索引。              
 (2).基于Zookeeper有序节点：Zookeeper允许临时创建有序的子节点，这样客户端获取节点列表时，能够利用当前子节点列表中的序号判断是否能够获得锁；               
 (3).基于Redis的单线程                    
 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。           
 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。           
 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。                   
>               
>SETNX 和 EXPIRE 非原子性            
 如果 SETNX 成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 EXPIRE 命令没有执行，锁没有设置超时时间变成死锁。                   
>           
>锁误解除               
 如果线程A成功获取到了锁，并且设置了过期时间30秒，但线程 A执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，
>线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。              
 解决方法：通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。
>可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。             
>           
>超时解锁导致并发                       
 如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。                          
 A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：         
 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。             
 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。               
>               
>单点/多点问题:               
 如果 Redis 采用单机部署模式，那就意味着当 Redis 故障了，就会导致整个服务不可用。            
 如果采用主从模式部署,服务A申请到一把锁之后，如果作为主机的 Redis 宕机了，那么服务B在申请锁的时候就会从从机那里获取到这把锁，                
>可能会发生多个客户端同时持有一个锁的现象。              
>为了解决这个问题，Redis作者提出了一种 RedLock 红锁 的算法 (Redission 同 Jedis)：                  
 // 三个 Redis 集群             
 RLock lock1 = redissionInstance1.getLock("lock1");             
 RLock lock2 = redissionInstance2.getLock("lock2");             
 RLock lock3 = redissionInstance3.getLock("lock3");                 
 
>RedissionRedLock lock = new RedissionLock(lock1, lock2, lock2);                    
 lock.lock();                       
 // do something....                        
 lock.unlock();                     
>           
>客户端用相同的key和随机值在5个节点上请求锁，请求锁的超时时间应小于锁自动释放时间。当在3个（超过半数）redis上请求到锁的时候，
>才算是真正获取到了锁。如果没有获取到锁，则把部分已锁的redis释放掉。                               

>                           
>如何使用redis分布式锁：                 
>先用setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。                
 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？               
 这个锁就永远得不到释放了。                  
>set指令有非常复杂的参数，可以同时把setnx和expire合成一条指令来用。                
>或者使用具有原子性的lua脚本操作set和expire            
>                       
>redis分布式锁缺陷:               
>Redis分布式锁不能解决超时的问题，分布式锁有一个超时时间，程序的执行如果超出了锁的超时时间就会出现问题。                 
> 参考 https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/           
