redis知识
======
# 题目列表
# 题目答案
## 1.为什么用Redis？
>(1).性能:在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。                
 (2).并发:在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这时就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。                   
 (3).redis提供了相当丰富的string、hash、list、set、zset等数据结构。               
 (4).redis具备可以做分布式锁的功能。                 
 (5).redis支持数据的备份。              
## 2.redis有哪些数据结构？
>(1).基本数据类型:                                     
 [1].String:最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。                 
 [2].Hash:value存放的是结构化的对象，比较方便的就是操作其中的某个字段。             
 [3].List:做简单的消息队列的功能。可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。                
 [4].Set:不重复值、无序的集合。可以做全局去重的功能。利用其交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。                
 [5].SortedSet:比set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。另外，sorted set可以用来做延时任务和做范围查找。             
 (2).特殊数据结构:                           
 [1].HyperLogLog:Redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。                 
 [2].Geo:Redis的GEO是3.2版本的新特性。这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。                
 [3].Pub/Sub:“发布/订阅”在redis中，被设计的非常轻量级和简洁，它做到了消息的“发布”和“订阅”的基本能力;但是尚未提供关于消息的持久化等各种企业级的特性。                 
 一个Redis client发布消息,其他多个redis client订阅消息,发布的消息“即发即失”;                             
 redis不会持久保存发布的消息;                                        
 消息订阅者也将只能得到订阅之后的消息,通道中此前的消息将无从获得。                               
 (3)Redis Module                    
 [1].BloomFilter:布隆过滤器，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。
>检索时，只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。                        
 [2].RedisSearch:一个高性能的全文搜索引擎               
 [3].Redis-ML:实时机器学习                                    
## 3.如果有大量的key需要设置同一时间过期，需要注意什么？
>如果大量的key过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，一般需要在时间上加一个随机值，使得过期时间分散一些。                             
 电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩。                               
## 4.Redis分布式锁
>在系统中修改已有数据时，需要先读取，然后进行修改保存，此时很容易遇到并发问题。由于修改和保存不是原子操作，在并发场景下，部分对数据的操作可能会丢失。
>在单服务器系统常用本地锁来避免并发带来的问题，然而，当服务采用集群方式部署时，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。                  
 使用分布式锁有两个场景:                   
 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。            
 正确性:加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。         
>               
>分布式锁特点:            
 互斥性:和本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。             
 可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。             
 锁超时:和本地锁一样支持锁超时，防止死锁。              
 高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。                
 支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。            
 支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。       
>               
>常见的分布式锁：           
 (1).基于MySQL中的锁：                
 [1].利用主键唯一规则：在争抢锁的时候向DB中写一条记录，这条记录主要包含锁的id、当前占用锁的线程名、重入的次数和创建时间等，
>如果插入成功表示当前线程获取到了锁，如果插入失败那么证明锁被其他人占用，等待一会儿继续争抢，直到争抢到或者超时为止。         
 优点：实现简单                
 缺点：没有超时保护机制，mysql存在单点，并发量大的时候请求量太大、没有线程唤醒机制。           
 [2].利用Mysql行锁的特性：Mysql是有表锁、页锁和行锁的机制的，可以利用这个机制来实现锁。这里尽量使用行锁，它的吞吐量是最高的。          
 利用for update加显式的行锁，这样就能利用这个行级的排他锁来实现分布式锁了，同时unlock的时候只要释放commit这个事务，就能达到释放锁的目的。            
 优点：实现简单                
 缺点：连接池爆满和事务超时的单点问题，行锁升级为表锁的问题，并发量大的时候请求量太大、没有线程唤醒机制。               
 利用事务进行加锁的时候，query需要占用数据库连接，在行锁的时候连接不释放，这就会导致连接池爆满。同时由于事务是有超时时间的，过了超时时间自动回滚，会导致锁的释放，这个超时时间要把控好。             
 行锁升级为表锁的问题：Mysql行锁默认需要走索引，如果不走索引会导致锁表，如果可以，在sql中可以强制指定索引。              
 (2).基于Zookeeper有序节点：Zookeeper允许临时创建有序的子节点，这样客户端获取节点列表时，能够利用当前子节点列表中的序号判断是否能够获得锁；               
 (3).基于Redis的单线程                    
 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。           
 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。           
 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。                   
>               
>SETNX 和 EXPIRE 非原子性            
 如果 SETNX 成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 EXPIRE 命令没有执行，锁没有设置超时时间变成死锁。                   
>           
>锁误解除               
 如果线程A成功获取到了锁，并且设置了过期时间30秒，但线程 A执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，
>线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。              
 解决方法：通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。
>可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。             
>           
>超时解锁导致并发                       
 如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。                          
 A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：         
 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。             
 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。               
>               
>单点/多点问题:               
 如果 Redis 采用单机部署模式，那就意味着当 Redis 故障了，就会导致整个服务不可用。            
 如果采用主从模式部署,服务A申请到一把锁之后，如果作为主机的 Redis 宕机了，那么服务B在申请锁的时候就会从从机那里获取到这把锁，
>为了解决这个问题，Redis作者提出了一种 RedLock 红锁 的算法 (Redission 同 Jedis)：                  
 // 三个 Redis 集群             
 RLock lock1 = redissionInstance1.getLock("lock1");             
 RLock lock2 = redissionInstance2.getLock("lock2");             
 RLock lock3 = redissionInstance3.getLock("lock3");                 
 
>RedissionRedLock lock = new RedissionLock(lock1, lock2, lock2);                    
 lock.lock();                       
 // do something....                        
 lock.unlock();                         

>                           
>如何使用redis分布式锁：                 
>先用setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。                
 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？               
 这个锁就永远得不到释放了。                  
>set指令有非常复杂的参数，可以同时把setnx和expire合成一条指令来用。                
>或者使用具有原子性的lua脚本操作set和expire            
> 参考 https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/           
## 5.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？
>使用keys指令可以扫出指定模式的key列表。                    
 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？             
 Redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，
>scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
>增量式迭代命令也不是没有缺点的.举个例子:使用SMEMBERS命令可以返回集合键当前包含的所有元素， 但是对于SCAN这类增量式迭代命令来说，
> 因为在对键进行增量式迭代的过程中，键可能会被修改，所以增量式迭代命令只能对被返回的元素提供有限的保证。                   
## 6.如何使用Redis做异步队列？
>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。或者用指令blpop，在没有消息的时候，它会阻塞住直到消息到来。
## 7.Redis中如何实现消息生产一次消费多次？
>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
## 8.redis中pub/sub有什么缺点？
>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等。
## 9.Redis如何实现延时队列？
>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。
## 10.Redis是怎么持久化的？
>Redis有两种持久化方式:RDB和AOF。RDB做镜像全量持久化，AOF做增量持久化。               
 RDB在指定的时间间隔内将内存中的数据集快照（Snapshot快照）写入磁盘，它恢复时是将快照文件直接读到内存里。              
 redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。           
 Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。                    
>                   
>配置位置:              
 save 900 1         
 save 300 10            
 save 60 10000          
 RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件。默认 ：1分钟内改了1万次； 5分钟内改了10次；15分钟内改了1次。           
>                               
>禁用:如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以               
>                           
>如何触发RDB快照:                     
 save或bgsave命令会触发rdb快照。                     
 save时只管保存，其它不管，全部阻塞;使用bgsave命令时edis会在后台异步进行快照操作，快照同时还可以响应客户端请求。                
 可以通过lastsave命令获取最后一次成功执行快照的时间。                 
 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。                    
 如何恢复：将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。               
 config get dir获取目录                 
>                       
>优势:                    
 适合大规模的数据恢复                 
 单独创建（fork）一个子进程来进行持久化，父进程不需要做其他IO操作，RDB方式可以最大化redis的性能                 
 对数据完整性和一致性要求不高                 
 劣势:                
 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改；                  
 Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。                 
 停止rdb快照:                   
 动态停止RDB保存规则的方法：redis-cli config set save ""                                
>                           
>AOF以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)。只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据。                    
 redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作              
 aof保存的是appendonly.aof文件                
>                           
>配置位置:                  
 appendonly no                  
 appendfilename "appendonly.aof"                
>                       
>appendfsync:                   
 always:同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好               
 everysec:出厂默认推荐，异步操作，每秒记录 如果一秒内宕机，有数据丢失                    
 no：从不同步                
>                                              
>aof的启动、修复、恢复：                      
 正常恢复：                  
 修改默认的appendonly no，改为yes即启动aof持久化；             
 将有数据的aof文件复制一份保存到对应目录(config get dir)；                 
 重启redis然后重新加载appendonly.aof文件，完成恢复。            
 异常恢复：              
 修改默认的appendonly no，改为yes即启动aof持久化；             
 备份appendonly.aof文件；                
 运行redis-check-aof --fix appendonly.aof命令进行数据修复；                                
 重启redis然后重新加载appendonly.aof文件，完成恢复。   
>                                        
>rewrite:                         
 aof采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当aof文件的大小超过所设定的阈值时，redis就会启动aof文件的内容压缩，只保留可以恢复数据的最小指令集.               
 命令bgrewriteaof用于手动触发重写操作。即使bgrewriteaof执行失败，也不会有任何数据丢失，因为旧的aof文件在bgrewriteaof成功之前不会被修改。                
 重写原理:aof文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的set语句。             
 重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。                    
 触发机制:redis会记录上次重写时的aof大小，默认配置是当aof文件大小是上次rewrite后大小的一倍且文件大于64M时触发。                     
>                           
>优势：                
 每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好         
 每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失              
 不同步：appendfsync no 从不同步                    
 劣势：aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同
>                                       
>rdb和aof持久化选择哪一个？               
 只做缓存时可以不使用任何持久化方式。                 
 rdb文件只用作后备用途，建议只在slave上持久化rdb文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。             
 同时开启两种持久化方式：                   
 在这种情况下,当redis重启的时候会优先载入aof文件来恢复原始的数据,因为在通常情况下aof文件保存的数据集要比RDB文件保存的数据集要完整。
 rdb的数据不实时，同时使用两者时服务器重启也只会找aof文件。那要不要只使用aof呢？建议不要，因为rdb更适合用于备份数据库(aof在不断变化不好备份)，
 快速重启，而且不会有aof可能潜在的bug，留着作为一个万一的手段。                     
## 11.Pipeline有什么好处，为什么要用pipeline？
>pipeline的作用是将一批命令进行打包，然后发送给服务器，服务器执行完按顺序打包返回。          
 通过pipeline，一次pipeline（n条命令）=一次网络时间 + n次命令时间            
 pipeline可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。               
 pipeline注意事项:              
 每次pipeline携带数量不推荐过大，否则会影响网络性能              
 pipeline每次只能作用在一个Redis节点上              
## 12.Redis的同步机制？
>为了避免服务的单点故障，会把数据复制到多个副本放在不同的服务器上，且这些拥有数据副本的服务器可以用于处理客户端的读请求，扩展整体的性能。           
 Redis支持主从复制，Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制分为全量同步和增量同步。             
>               
>全量同步                             
 Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：               
 (1).从服务器连接主服务器，发送SYNC命令；               
 (2).主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；              
 (3).主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；                
 (4).从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；                
 (5).主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；              
 (6).从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；                
> ![redis](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis.png)              
>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。                
>               
>增量同步                                  
 Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。                                 
 增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。             
>               
>主从复制的特点：               
 (1).采用异步复制；                    
 (2).一个主redis可以含有多个从redis；              
 (3).每个从redis可以接收来自其他从redis服务器的连接；          
 (4).主从复制对于主redis服务器来说是非阻塞的，这意味着当从服务器在进行主从复制同步过程中，主redis仍然可以处理外界的访问请求；              
 (5).主从复制对于从redis服务器来说也是非阻塞的，这意味着，即使从redis在进行主从复制过程中也可以接受外界的查询请求，
>只不过这时候从redis返回的是以前老的数据，如果你不想这样，那么在启动redis时，可以在配置文件中进行设置，那么从redis
>在复制同步过程中来自外界的查询请求都会返回错误给客户端；（虽然说主从复制过程中对于从redis是非阻塞的，但是当从redis
>从主redis同步过来最新的数据后还需要将新数据加载到内存中，在加载到内存的过程中是阻塞的，在这段时间内的请求将会被阻，
>但是即使对于大数据集，加载到内存的时间也是比较多的）；                    
 (6).主从复制提高了redis服务的扩展性，避免单个redis服务器的读写访问压力过大的问题，同时也可以给为数据备份及冗余提供一种解决方案；                
 (7).为了减少主redis服务器写磁盘压力带来的开销，可以配置让主redis不在将数据持久化到磁盘，而是通过连接让一个配置的从redis服务器及时的将相关
>数据持久化到磁盘，不过这样会存在一个问题，就是主redis服务器一旦重启，因为主redis服务器数据为空，这时候通过主从同步可能导致从redis服务器上的数据也被清空。               
>                               
>部分同步:              
 从redis 2.8版本以前，并不支持部分同步，当主从服务器之间的连接断掉之后，master服务器和slave服务器之间都是进行全量数据同步，
>但是从redis 2.8开始，即使主从连接中途断掉，也不需要进行全量同步。部分同步的实现依赖于在master服务器内存中给每个slave服务器
>维护了一份同步日志和同步标识，每个slave服务器在跟master服务器进行同步时都会携带自己的同步标识和上次同步的最后位置。当主从连
>接断掉之后，slave服务器隔断时间（默认1s）主动尝试和master服务器进行连接，如果从服务器携带的偏移量标识还在master服务器上的
>同步备份日志中，那么就从slave发送的偏移量开始继续上次的同步操作，如果slave发送的偏移量已经不再master的同步备份日志中（可能
>由于主从之间断掉的时间比较长或者在断掉的短暂时间内master服务器接收到大量的写操作），则必须进行一次全量更新。在部分同步过程中，
>master会将本地记录的同步备份日志中记录的指令依次发送给slave服务器从而达到数据一致。                    
>               
>主从复制的好处：                   
 数据冗余，实现数据的热备份                  
 故障恢复，避免单点故障带来的服务不可用                
 读写分离，负载均衡。主节点负载读写，从节点负责读，提高服务器并发量              
 高可用基础，是哨兵机制和集群实现的基础                                  
>                                          
>一主多从:一个master可以有多个slave            
>查看机器主从复制情况的命令：info replication                                        
>slaveof ip port                
 问:切入点问题：slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1、k2、k3是否也可以复制？          
 答:从头开始复制                     
 问:从机是否可以写？set可否？             
 答:从机不可写              
 问:主机shutdown后情况如何？从机是上位还是原地待命？               
 答:原地待命               
 问:主机又回来了后，主机新增记录，从机还能否顺利复制？              
 答:能              
 问:其中一台从机down后情况如何？依照原有它能跟上大部队吗？                  
 答:不能，每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件。               
>                                   
>级联结构(薪火相传)                     
>上一个slave可以是下一个slave的master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。                  
 中途变更转向:会清除之前的数据，重新建立拷贝最新的。slaveof 新主库IP 新主库端口                  
>                   
>哨兵模式(sentinel)                 
>哨兵模式是一种特殊的模式，它是Redis高可用的一种实现方案。哨兵是一个独立的Redis服务端进程， 可以实现对Redis实例的监控、通知、自动故障转移、配置提供。                                   
>监控(Monitoring)：哨兵(sentinel) 会不断地检查你的 Master 和 Slave 是否运作正常。                
 提醒(Notification)：当被监控的某个 Redis 出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。          
 自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,
>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master; 当客户端试图连接失效的
>Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。                             
>配置提供（Configuration provider）：客户端可以把 Sentinel 作为权威的配置发布者来获得最新的master地址。如果发生了故障转移，
>Sentinel集群会通知客户端新的 master 地址，并刷新 Redis 的配置。       
>               
>定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：通过向主从节点发送info命令获取最新的主从结构；
>通过发布订阅功能获取其他哨兵节点的信息；通过向其他节点发送ping命令进行心跳检测，判断是否下线。                  
 主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。
>顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。           
 客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；
>如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。             
 需要特别注意的是，客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。         
 选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。
 监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请
>，如果B没有同意过其他哨兵，则会同意A成为领导者。一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。            
 故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤：                           
 在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；
>如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。
 更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。       
>           
>Sentinel缺陷:            
 Sentinel模式下，写操作仍然只能在Sentinel提供的master数据节点上执行，无法负载均衡                
 持久化时master节点刷盘阻塞，服务请求成功率下降             
 slave节点存储能力受到单机的限制         
 分区问题:原master redis3断开与redis1和redis2的连接，此时redis1和redis2执行故障转移，选择redis1为master。
>这时，redis1和redis3都能接受写请求，但数据无法同步，数据不一致。                                                                               
## 13.Redis集群的高可用怎么保证，集群的原理是什么？
>分布式系统（distributed system）              
 由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，
>所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。
>分布式系统可以应用在不同的平台上如：PC、工作站、局域网和广域网上等。                    
 分布式:不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。              
 集群:不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。                    
>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
 Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
## 14.NoSQL数据库的分类？
>KV键值：memcache redis                    
 文档型数据库(bson格式比较多)：MongoDB              
 列存储数据库                         
 图关系数据库                     
## 15.CAP理论
>CAP：Consistency（强一致性） Availability（可用性） Partition tolerance（分区容错性）                     
 CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是必须需要实现的。                    
 只能在一致性和可用性之间进行权衡， 没有NoSQL系统能同时保证这三点。                               
 C:强一致性(所有节点在同一时间具有相同的数据)                       
>A:高可用性(保证每个请求不管成功或者失败都有响应)                           
>P:分布式容忍性(系统中任意信息的丢失或失败不会影响系统的继续运作)                                        
 注意：分布式架构的时候必须做出取舍。             
 一致性和可用性之间取一个平衡。大多数web应用，其实并不需要强一致性。 因此牺牲C换取P，这是目前分布式数据库产品的方向。              
 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。               
 因此，根据 CAP 原理将 NoSQL 数据库分成了满足CA原则、满足CP原则和满足AP原则三 大类：                    
 CA:单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。RDMS                 
 CP:满足一致性，分区容忍性的系统，通常性能不是特别高。MongoDB,Redis,HBase                    
 AP:满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。大多数网站架构的选择。CouchDB,Cassandra,DynamoDB,Riak                              
## 16.BASE理论
>CAP理论的核心是:一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。               
 BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:                 
 基本可用(Basically Available)              
 软状态/柔性事务(Soft State) "Soft state" 可以理解为"无连接"的, 而 "Hard state" 是"面向连接"的         
 最终一致性(Eventually Consistency), 也是 ACID 的最终目的。              
 它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。大型系统往往由于地域分布和极高性能的要求，
>不可能采用分布式事务来完成这些指标，要想获得这些指标，必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法。                
## 17.Redis和Memcached的区别？
>Redis和Memcache都是将数据存放在内存中，都是内存数据库。                             
 两者的主要区别:                       
 (1).支持的数据类型不同                  
 Redis支持的数据类型丰富,不仅支持简单的k/v类型的数据，同时还提供String，List,Set,Hash,Sorted Set,pub/sub,Transactions数据结构的存储。                       
 memcache支持简单数据类型，需要客户端自己处理复杂对象。不过memcache还可用于缓存图片、视频等其他东西。                         
 (2).对持久性的支持不同                  
 redis支持数据落地持久化存储,可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。                  
 memcache不支持数据持久存储。                 
 (3).扩展性的实现方式(分布式存储)不同                  
 redis支持master-slave复制模式                        
 memcached本身并不支持分布式，只能在客户端通过像一致性哈希这样的分布式算法来实现memcached的分布式存储。               
 (4).性能不同               
 由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，
>Memcached性能要高于Redis，虽然Redis也在存储大数据的性能上进行了优化，但是比起Memcached，还是稍有逊色。                  
 (5).存储数据安全性不同                      
 redis中的数据可以定期保存到磁盘（持久化，redis挂掉后，数据可以通过aof、rdb恢复                        
 memcache挂掉后，数据没了，数据不可恢复                    
 (6).过期策略不同                     
 redis在set的时候可以不指定，然后通过expire设定，例如expire name 10                        
 memcache在set时就指定，例如set key1 0 0 8,即永不过期                        
## 18.单线程的redis为什么这么快
>Redis到底有多快:                            
>redis性能卓越,作为key-value系统最大负载数量级为10W/s,set和get耗时数量级为10ms和5ms。使用流水线的方式可以提升redis操作的性能。                     
>                                   
>Redis为什么那么快:                                      
>内存存储：Redis是使用内存(in-memeroy)存储,没有磁盘IO上的开销                                  
 单线程实现：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销                                  
 非阻塞IO：Redis使用多路复用IO技术，在poll，epool，kqueue选择最优IO实现                             
 优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能                                        
>参考 https://segmentfault.com/a/1190000022088928             
## 19.redis的过期策略以及内存淘汰机制
>缓存是指在第一次获取到数据时，把它暂存在内存中。下次需要这个数据时，就直接从内存中取，不用再去查询数据库或调用远程接口，这样可以极大地提高应用程序的性能。                  
 如果缓存中的数据永久存在，那占用的内存就会变得越来越大。而内存是有限的，所以缓存系统需要在需要的时候删除一些不必要的缓存数据以节约内存空间。                 
 Redis提供了过期策略和内存淘汰这两种机制配合来达到删除一些不必要的缓存数据以节约内存空间目的。                  
>               
>Redis是使用定期删除+惰性删除两者配合的过期策略。                
 定期删除是指Redis默认每隔100ms就随机抽取一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删掉。                     
 因为key太多，如果全盘扫描所有的key会非常耗性能，所以是随机抽取一些key来删除。这样就有可能删除不完，需要惰性删除配合。                    
 惰性删除不再是Redis去主动删除，而是在客户端要获取某个key的时候，Redis会先去检测一下这个key是否已经过期，如果没有过期则返回给客户端，
>如果已经过期了，那么Redis会删除这个key，不会返回给客户端。              
 所以惰性删除可以解决一些过期了，但没被定期删除随机抽取到的key。但有些过期的key既没有被随机抽取，也没有被客户端访问，就会一直保留在数据库，
>占用内存，长期下去可能会导致内存耗尽。所以Redis提供了内存淘汰机制来解决这个问题。                            
>                               
>为什么不使用定时删除？                            
 所谓定时删除，指的是用一个定时器来负责监视key，当这个key过期就自动删除，虽然内存及时释放，但是十分消耗CPU资源，因此一般不推荐采用这一策略。                         
>                               
>内存淘汰机制                             
 Redis在使用内存达到某个阈值时（通过maxmemory配置)，就会触发内存淘汰机制，选取一些key来删除。                        
># maxmemory <bytes> 配置内存阈值                             
># maxmemory-policy allkeys-lru                                         
>内存淘汰策略:                    
 noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。默认策略                    
 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。                             
 allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。                                     
 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。                            
 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。                        
 volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。                                 
>                           
>如何选取合适的策略？                                 
 比较推荐的是两种lru策略。根据自己的业务需求。如果你使用Redis只是作为缓存，不作为DB持久化，那推荐选择allkeys-lru；
>如果你使用Redis同时用于缓存和数据持久化，那推荐选择volatile-lru。                              
 如果没有设置expire的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。                      
## 20.使用redis的缺点?
>(1).缓存和数据库双写一致性问题
>(2).缓存雪崩问题
>(3).缓存击穿问题
>(4).缓存穿透问题
>(5).如何解决redis的并发竞争key问题(有多个子系统去set一个key)                               
[1].如果对这个key操作不要求顺序,则准备一个分布式锁，多个子系统去抢锁，抢到锁就做set操作即可。                                                
[2].如果对这个key操作要求顺序。假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC。               
期望按照key1的value值按照 valueA-->valueB-->valueC的顺序变化。                                                     
a.利用队列，将set方法变成串行访问。                                                                       
b.保存一个时间戳。假设时间戳如下:                                      
系统A key1 {valueA  3:00}                                                      
系统B key1 {valueB  3:05}                                            
系统C key1 {valueC  3:10}                                                    
那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。                                     
>                       
>乐观锁不要在分片集群中使用                      