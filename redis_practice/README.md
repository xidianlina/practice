redis知识
======
# 题目列表
# 题目答案
## 1.为什么用Redis？
>(1).性能:在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。                
 (2).并发:在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这时就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。                   
 (3).redis提供了相当丰富的string、hash、list、set、zset等数据结构。               
 (4).redis具备可以做分布式锁的功能。                 
 (5).redis支持数据的备份。              
## 2.redis有哪些数据结构？
>(1).基本数据类型:                                     
 [1].String:最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。                 
 [2].Hash:value存放的是结构化的对象，比较方便的就是操作其中的某个字段。             
 [3].List:做简单的消息队列的功能。可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。                
 [4].Set:不重复值、无序的集合。可以做全局去重的功能。利用其交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。                
 [5].SortedSet:比set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。另外，sorted set可以用来做延时任务和做范围查找。             
 (2).特殊数据结构:                           
 [1].HyperLogLog:Redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。                 
 [2].Geo:Redis的GEO是3.2版本的新特性。这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。                
 [3].Pub/Sub:“发布/订阅”在redis中，被设计的非常轻量级和简洁，它做到了消息的“发布”和“订阅”的基本能力;但是尚未提供关于消息的持久化等各种企业级的特性。                 
 一个Redis client发布消息,其他多个redis client订阅消息,发布的消息“即发即失”;                             
 redis不会持久保存发布的消息;                                        
 消息订阅者也将只能得到订阅之后的消息,通道中此前的消息将无从获得。                               
 (3)Redis Module                    
 [1].BloomFilter:布隆过滤器，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。
>检索时，只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。                        
 [2].RedisSearch:一个高性能的全文搜索引擎               
 [3].Redis-ML:实时机器学习                                    
## 3.如果有大量的key需要设置同一时间过期，需要注意什么？
>如果大量的key过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，一般需要在时间上加一个随机值，使得过期时间分散一些。                             
 电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩。                               
## 4.Redis分布式锁
>在系统中修改已有数据时，需要先读取，然后进行修改保存，此时很容易遇到并发问题。由于修改和保存不是原子操作，在并发场景下，部分对数据的操作可能会丢失。
>在单服务器系统常用本地锁来避免并发带来的问题，然而，当服务采用集群方式部署时，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。                  
 使用分布式锁有两个场景:                   
 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。            
 正确性:加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。         
>               
>分布式锁特点:            
 互斥性:和本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。             
 可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。             
 锁超时:和本地锁一样支持锁超时，防止死锁。              
 高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。                
 支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。            
 支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。       
>               
>常见的分布式锁：           
 (1).基于MySQL中的锁：                
 [1].利用主键唯一规则：在争抢锁的时候向DB中写一条记录，这条记录主要包含锁的id、当前占用锁的线程名、重入的次数和创建时间等，
>如果插入成功表示当前线程获取到了锁，如果插入失败那么证明锁被其他人占用，等待一会儿继续争抢，直到争抢到或者超时为止。         
 优点：实现简单                
 缺点：没有超时保护机制，mysql存在单点，并发量大的时候请求量太大、没有线程唤醒机制。           
 [2].利用Mysql行锁的特性：Mysql是有表锁、页锁和行锁的机制的，可以利用这个机制来实现锁。这里尽量使用行锁，它的吞吐量是最高的。          
 利用for update加显式的行锁，这样就能利用这个行级的排他锁来实现分布式锁了，同时unlock的时候只要释放commit这个事务，就能达到释放锁的目的。            
 优点：实现简单                
 缺点：连接池爆满和事务超时的单点问题，行锁升级为表锁的问题，并发量大的时候请求量太大、没有线程唤醒机制。               
 利用事务进行加锁的时候，query需要占用数据库连接，在行锁的时候连接不释放，这就会导致连接池爆满。同时由于事务是有超时时间的，过了超时时间自动回滚，会导致锁的释放，这个超时时间要把控好。             
 行锁升级为表锁的问题：Mysql行锁默认需要走索引，如果不走索引会导致锁表，如果可以，在sql中可以强制指定索引。              
 (2).基于Zookeeper有序节点：Zookeeper允许临时创建有序的子节点，这样客户端获取节点列表时，能够利用当前子节点列表中的序号判断是否能够获得锁；               
 (3).基于Redis的单线程                    
 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。           
 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。           
 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。                   
>               
>SETNX 和 EXPIRE 非原子性            
 如果 SETNX 成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 EXPIRE 命令没有执行，锁没有设置超时时间变成死锁。                   
>           
>锁误解除               
 如果线程A成功获取到了锁，并且设置了过期时间30秒，但线程 A执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，
>线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。              
 解决方法：通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。
>可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。             
>           
>超时解锁导致并发                       
 如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。                          
 A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：         
 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。             
 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。               
>               
>单点/多点问题:               
 如果 Redis 采用单机部署模式，那就意味着当 Redis 故障了，就会导致整个服务不可用。            
 如果采用主从模式部署,服务A申请到一把锁之后，如果作为主机的 Redis 宕机了，那么服务B在申请锁的时候就会从从机那里获取到这把锁，
>为了解决这个问题，Redis作者提出了一种 RedLock 红锁 的算法 (Redission 同 Jedis)：                  
 // 三个 Redis 集群             
 RLock lock1 = redissionInstance1.getLock("lock1");             
 RLock lock2 = redissionInstance2.getLock("lock2");             
 RLock lock3 = redissionInstance3.getLock("lock3");                 
 
>RedissionRedLock lock = new RedissionLock(lock1, lock2, lock2);                    
 lock.lock();                       
 // do something....                        
 lock.unlock();                         

>                           
>如何使用redis分布式锁：                 
>先用setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。                
 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？               
 这个锁就永远得不到释放了。                  
>set指令有非常复杂的参数，可以同时把setnx和expire合成一条指令来用。                
>或者使用具有原子性的lua脚本操作set和expire            
> 参考 https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/           
## 5.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？
>使用keys指令可以扫出指定模式的key列表。                    
 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？             
 Redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，
>scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
>增量式迭代命令也不是没有缺点的.举个例子:使用SMEMBERS命令可以返回集合键当前包含的所有元素， 但是对于SCAN这类增量式迭代命令来说，
> 因为在对键进行增量式迭代的过程中，键可能会被修改，所以增量式迭代命令只能对被返回的元素提供有限的保证。                   
## 6.如何使用Redis做异步队列？
>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。或者用指令blpop，在没有消息的时候，它会阻塞住直到消息到来。
## 7.Redis中如何实现消息生产一次消费多次？
>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
## 8.redis中pub/sub有什么缺点？
>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等。
## 9.Redis如何实现延时队列？
>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。
## 10.Redis是怎么持久化的？
>Redis有两种持久化方式:RDB和AOF。RDB做镜像全量持久化，AOF做增量持久化。               
 RDB在指定的时间间隔内将内存中的数据集快照（Snapshot快照）写入磁盘，它恢复时是将快照文件直接读到内存里。              
 redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。           
 Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。                    
>                   
>配置位置:              
 save 900 1         
 save 300 10            
 save 60 10000          
 RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件。默认 ：1分钟内改了1万次； 5分钟内改了10次；15分钟内改了1次。           
>                               
>禁用:如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以               
>                           
>如何触发RDB快照:                     
 save或bgsave命令会触发rdb快照。                     
 save时只管保存，其它不管，全部阻塞;使用bgsave命令时edis会在后台异步进行快照操作，快照同时还可以响应客户端请求。                
 可以通过lastsave命令获取最后一次成功执行快照的时间。                 
 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。                    
 如何恢复：将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。               
 config get dir获取目录                 
>                       
>优势:                    
 适合大规模的数据恢复                 
 单独创建（fork）一个子进程来进行持久化，父进程不需要做其他IO操作，RDB方式可以最大化redis的性能                 
 对数据完整性和一致性要求不高                 
 劣势:                
 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改；                  
 Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。                 
 停止rdb快照:                   
 动态停止RDB保存规则的方法：redis-cli config set save ""                                
>                           
>AOF以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)。只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据。                    
 redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作              
 aof保存的是appendonly.aof文件                
>                           
>配置位置:                  
 appendonly no                  
 appendfilename "appendonly.aof"                
>                       
>appendfsync:                   
 always:同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好               
 everysec:出厂默认推荐，异步操作，每秒记录 如果一秒内宕机，有数据丢失                    
 no：从不同步                
>                                              
>aof的启动、修复、恢复：                      
 正常恢复：                  
 修改默认的appendonly no，改为yes即启动aof持久化；             
 将有数据的aof文件复制一份保存到对应目录(config get dir)；                 
 重启redis然后重新加载appendonly.aof文件，完成恢复。            
 异常恢复：              
 修改默认的appendonly no，改为yes即启动aof持久化；             
 备份appendonly.aof文件；                
 运行redis-check-aof --fix appendonly.aof命令进行数据修复；                                
 重启redis然后重新加载appendonly.aof文件，完成恢复。   
>                                        
>rewrite:                         
 aof采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当aof文件的大小超过所设定的阈值时，redis就会启动aof文件的内容压缩，只保留可以恢复数据的最小指令集.               
 命令bgrewriteaof用于手动触发重写操作。即使bgrewriteaof执行失败，也不会有任何数据丢失，因为旧的aof文件在bgrewriteaof成功之前不会被修改。                
 重写原理:aof文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的set语句。             
 重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。                    
 触发机制:redis会记录上次重写时的aof大小，默认配置是当aof文件大小是上次rewrite后大小的一倍且文件大于64M时触发。                     
>                           
>优势：                
 每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好         
 每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失              
 不同步：appendfsync no 从不同步                    
 劣势：aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同
>                                       
>rdb和aof持久化选择哪一个？               
 只做缓存时可以不使用任何持久化方式。                 
 rdb文件只用作后备用途，建议只在slave上持久化rdb文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。             
 同时开启两种持久化方式：                   
 在这种情况下,当redis重启的时候会优先载入aof文件来恢复原始的数据,因为在通常情况下aof文件保存的数据集要比RDB文件保存的数据集要完整。
 rdb的数据不实时，同时使用两者时服务器重启也只会找aof文件。那要不要只使用aof呢？建议不要，因为rdb更适合用于备份数据库(aof在不断变化不好备份)，
 快速重启，而且不会有aof可能潜在的bug，留着作为一个万一的手段。                     
## 11.Pipeline有什么好处，为什么要用pipeline？
>pipeline的作用是将一批命令进行打包，然后发送给服务器，服务器执行完按顺序打包返回。          
 通过pipeline，一次pipeline（n条命令）=一次网络时间 + n次命令时间            
 pipeline可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。               
 pipeline注意事项:              
 每次pipeline携带数量不推荐过大，否则会影响网络性能              
 pipeline每次只能作用在一个Redis节点上              
## 12.Redis的同步机制？
>
## 13.Redis集群的高可用怎么保证，集群的原理是什么？
>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
 Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
## 14.
>
## 15.
>
## 16.
>
## 17.
>
## 18.
>
## 19.
>