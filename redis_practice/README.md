redis知识
======
# 题目列表
## 1.为什么用Redis？
## 2.redis有哪些数据结构？
## 3.如果有大量的key需要设置同一时间过期，需要注意什么？
## 4.Redis分布式锁
## 5.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？
## 6.如何使用Redis做异步队列？
## 7.Redis中如何实现消息生产一次消费多次？
## 8.redis中pub/sub有什么缺点？
## 9.Redis如何实现延时队列？
## 10.Redis是怎么持久化的？
## 11.Pipeline有什么好处，为什么要用pipeline？
## 12.Redis的同步机制？
## 13.Redis集群的高可用怎么保证，集群的原理是什么？
## 14.NoSQL数据库的分类？
## 15.CAP理论
## 16.BASE理论
## 17.Redis和Memcached的区别？
## 18.单线程的redis为什么这么快
## 19.redis的过期策略以及内存淘汰机制
## 20.使用redis的缺点?
## 21.缓存预热                                       
## 22.缓存降级
## 23.布隆过滤器                         
## 24.跳跃表                              
## 25.字符串类型值存储最大容量是多少？默认有多少个库？Redis集群之间是如何复制的？Redis集群最大节点个数是多少？          
## 26.Redis 如何设置密码及验证密码？             
## 27.Redis 集群会有写操作丢失吗？为什么？ 
## 28.MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
## 29.Redis最适合的场景？
## 30.关系型数据库跟Redis本质上的区别    
## 31.如何使用 Redis 更节省内存？

# 题目答案
## 1.为什么用Redis？
>(1).性能:在碰到需要执行耗时特别久，且结果不频繁变动的SQL，就特别适合将运行结果放入缓存。这样，后面的请求就去缓存中读取，使得请求能够迅速响应。                
 (2).并发:在大并发的情况下，所有的请求直接访问数据库，数据库会出现连接异常。这时就需要使用redis做一个缓冲操作，让请求先访问到redis，而不是直接访问数据库。                   
 (3).redis提供了相当丰富的string、hash、list、set、zset等数据结构。               
 (4).redis具备可以做分布式锁的功能。                 
 (5).redis支持数据的备份。              
## 2.redis有哪些数据结构？
>(1).基本数据类型:                                     
 [1].String:最常规的set/get操作，value可以是String也可以是数字。一般做一些复杂的计数功能的缓存。                 
 [2].Hash:value存放的是结构化的对象，比较方便的就是操作其中的某个字段。             
 [3].List:做简单的消息队列的功能。可以利用lrange命令，做基于redis的分页功能，性能极佳，用户体验好。                
 [4].Set:不重复值、无序的集合。可以做全局去重的功能。利用其交集、并集、差集等操作，可以计算共同喜好，全部的喜好，自己独有的喜好等功能。                
 [5].SortedSet:比set多了一个权重参数score,集合中的元素能够按score进行排列。可以做排行榜应用，取TOP N操作。另外，sorted set可以用来做延时任务和做范围查找。             
 (2).特殊数据结构:                           
 [1].HyperLogLog:Redis HyperLogLog是用来做基数统计的算法，HyperLogLog的优点是，在输入元素的数量或者体积非常非常大时，计算基数所需的空间总是固定的、并且是很小的。                 
 [2].Geo:Redis的GEO是3.2版本的新特性。这个功能可以将用户给定的地理位置信息储存起来， 并对这些信息进行操作。                
 [3].Pub/Sub:“发布/订阅”在redis中，被设计的非常轻量级和简洁，它做到了消息的“发布”和“订阅”的基本能力;但是尚未提供关于消息的持久化等各种企业级的特性。                 
 一个Redis client发布消息,其他多个redis client订阅消息,发布的消息“即发即失”;                             
 redis不会持久保存发布的消息;                                        
 消息订阅者也将只能得到订阅之后的消息,通道中此前的消息将无从获得。                               
 (3)Redis Module                    
 [1].BloomFilter:布隆过滤器，当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。
>检索时，只要看看这些点是不是都是1就（大约）知道集合中有没有它了：如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。                        
 [2].RedisSearch:一个高性能的全文搜索引擎               
 [3].Redis-ML:实时机器学习                                    
## 3.如果有大量的key需要设置同一时间过期，需要注意什么？
>如果大量的key过期时间设置的过于集中，到过期的那个时间点，Redis可能会出现短暂的卡顿现象。严重的话会出现缓存雪崩，一般需要在时间上加一个随机值，使得过期时间分散一些。                             
 电商首页经常会使用定时任务刷新缓存，可能大量的数据失效时间都十分集中，如果失效时间一样，又刚好在失效的时间点大量用户涌入，就有可能造成缓存雪崩。                               
## 4.Redis分布式锁
>在系统中修改已有数据时，需要先读取，然后进行修改保存，此时很容易遇到并发问题。由于修改和保存不是原子操作，在并发场景下，部分对数据的操作可能会丢失。
>在单服务器系统常用本地锁来避免并发带来的问题，然而，当服务采用集群方式部署时，本地锁无法在多个服务器之间生效，这时候保证数据的一致性就需要分布式锁来实现。                  
 使用分布式锁有两个场景:                   
 效率:使用分布式锁可以避免不同节点重复相同的工作，这些工作会浪费资源。比如用户付了钱之后有可能不同节点会发出多封短信。            
 正确性:加分布式锁同样可以避免破坏正确性的发生，如果两个节点在同一条数据上面操作，比如多个节点机器对同一个订单操作不同的流程有可能会导致该笔订单最后状态出现错误，造成损失。         
>               
>分布式锁特点:            
 互斥性:和本地锁一样互斥性是最基本，但是分布式锁需要保证在不同节点的不同线程的互斥。             
 可重入性:同一个节点上的同一个线程如果获取了锁之后那么也可以再次获取这个锁。             
 锁超时:和本地锁一样支持锁超时，防止死锁。              
 高效，高可用:加锁和解锁需要高效，同时也需要保证高可用防止分布式锁失效，可以增加降级。                
 支持阻塞和非阻塞:和ReentrantLock一样支持lock和trylock以及tryLock(long timeOut)。            
 支持公平锁和非公平锁(可选):公平锁的意思是按照请求加锁的顺序获得锁，非公平锁就相反是无序的。这个一般来说实现的比较少。       
>               
>常见的分布式锁：           
 (1).基于MySQL中的锁：                
 [1].利用主键唯一规则：在争抢锁的时候向DB中写一条记录，这条记录主要包含锁的id、当前占用锁的线程名、重入的次数和创建时间等，
>如果插入成功表示当前线程获取到了锁，如果插入失败那么证明锁被其他人占用，等待一会儿继续争抢，直到争抢到或者超时为止。         
 优点：实现简单                
 缺点：没有超时保护机制，mysql存在单点，并发量大的时候请求量太大、没有线程唤醒机制。           
 [2].利用Mysql行锁的特性：Mysql是有表锁、页锁和行锁的机制的，可以利用这个机制来实现锁。这里尽量使用行锁，它的吞吐量是最高的。          
 利用for update加显式的行锁，这样就能利用这个行级的排他锁来实现分布式锁了，同时unlock的时候只要释放commit这个事务，就能达到释放锁的目的。            
 优点：实现简单                
 缺点：连接池爆满和事务超时的单点问题，行锁升级为表锁的问题，并发量大的时候请求量太大、没有线程唤醒机制。               
 利用事务进行加锁的时候，query需要占用数据库连接，在行锁的时候连接不释放，这就会导致连接池爆满。同时由于事务是有超时时间的，过了超时时间自动回滚，会导致锁的释放，这个超时时间要把控好。             
 行锁升级为表锁的问题：Mysql行锁默认需要走索引，如果不走索引会导致锁表，如果可以，在sql中可以强制指定索引。              
 (2).基于Zookeeper有序节点：Zookeeper允许临时创建有序的子节点，这样客户端获取节点列表时，能够利用当前子节点列表中的序号判断是否能够获得锁；               
 (3).基于Redis的单线程                    
 加锁命令：SETNX key value，当键不存在时，对键进行设置操作并返回成功，否则返回失败。KEY 是锁的唯一标识，一般按业务来决定命名。           
 解锁命令：DEL key，通过删除键值对释放锁，以便其他线程可以通过 SETNX 命令来获取锁。           
 锁超时：EXPIRE key timeout, 设置 key 的超时时间，以保证即使锁没有被显式释放，锁也可以在一定时间后自动释放，避免资源被永远锁住。                   
>               
>SETNX 和 EXPIRE 非原子性            
 如果 SETNX 成功，在设置锁超时时间后，服务器挂掉、重启或网络问题等，导致 EXPIRE 命令没有执行，锁没有设置超时时间变成死锁。                   
>           
>锁误解除               
 如果线程A成功获取到了锁，并且设置了过期时间30秒，但线程 A执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁；随后 A 执行完成，
>线程 A 使用 DEL 命令来释放锁，但此时线程 B 加的锁还没有执行完成，线程 A 实际释放的线程 B 加的锁。              
 解决方法：通过在 value 中设置当前线程加锁的标识，在删除之前验证 key 对应的 value 判断锁是否是当前线程持有。
>可生成一个 UUID 标识当前线程，使用 lua 脚本做验证标识和解锁操作。             
>           
>超时解锁导致并发                       
 如果线程 A 成功获取锁并设置过期时间 30 秒，但线程 A 执行时间超过了 30 秒，锁过期自动释放，此时线程 B 获取到了锁，线程 A 和线程 B 并发执行。                          
 A、B 两个线程发生并发显然是不被允许的，一般有两种方式解决该问题：         
 将过期时间设置足够长，确保代码逻辑在锁释放之前能够执行完成。             
 为获取锁的线程增加守护线程，为将要过期但未释放的锁增加有效时间。               
>               
>单点/多点问题:               
 如果 Redis 采用单机部署模式，那就意味着当 Redis 故障了，就会导致整个服务不可用。            
 如果采用主从模式部署,服务A申请到一把锁之后，如果作为主机的 Redis 宕机了，那么服务B在申请锁的时候就会从从机那里获取到这把锁，
>为了解决这个问题，Redis作者提出了一种 RedLock 红锁 的算法 (Redission 同 Jedis)：                  
 // 三个 Redis 集群             
 RLock lock1 = redissionInstance1.getLock("lock1");             
 RLock lock2 = redissionInstance2.getLock("lock2");             
 RLock lock3 = redissionInstance3.getLock("lock3");                 
 
>RedissionRedLock lock = new RedissionLock(lock1, lock2, lock2);                    
 lock.lock();                       
 // do something....                        
 lock.unlock();                         

>                           
>如何使用redis分布式锁：                 
>先用setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。                
 如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？               
 这个锁就永远得不到释放了。                  
>set指令有非常复杂的参数，可以同时把setnx和expire合成一条指令来用。                
>或者使用具有原子性的lua脚本操作set和expire            
> 参考 https://xiaomi-info.github.io/2019/12/17/redis-distributed-lock/           
## 5.假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如何将它们全部找出来？
>使用keys指令可以扫出指定模式的key列表。                    
 如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？             
 Redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，
>scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。
>增量式迭代命令也不是没有缺点的.举个例子:使用SMEMBERS命令可以返回集合键当前包含的所有元素， 但是对于SCAN这类增量式迭代命令来说，
> 因为在对键进行增量式迭代的过程中，键可能会被修改，所以增量式迭代命令只能对被返回的元素提供有限的保证。                   
## 6.如何使用Redis做异步队列？
>一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。或者用指令blpop，在没有消息的时候，它会阻塞住直到消息到来。
## 7.Redis中如何实现消息生产一次消费多次？
>使用pub/sub主题订阅者模式，可以实现1:N的消息队列。
## 8.redis中pub/sub有什么缺点？
>在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如RocketMQ等。
## 9.Redis如何实现延时队列？
>使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。
## 10.Redis是怎么持久化的？
>Redis有两种持久化方式:RDB和AOF。RDB做镜像全量持久化，AOF做增量持久化。               
 RDB在指定的时间间隔内将内存中的数据集快照（Snapshot快照）写入磁盘，它恢复时是将快照文件直接读到内存里。              
 redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个临时文件中，待持久化过程都结束了，再用这个临时文件替换上次持久化好的文件。整个过程中，主进程是不进行任何IO操作的。           
 Fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。                    
>                   
>配置位置:              
 save 900 1         
 save 300 10            
 save 60 10000          
 RDB是整个内存的压缩过的Snapshot，RDB的数据结构，可以配置复合的快照触发条件。默认 ：1分钟内改了1万次； 5分钟内改了10次；15分钟内改了1次。           
>                               
>禁用:如果想禁用RDB持久化的策略，只要不设置任何save指令，或者给save传入一个空字符串参数也可以               
>                           
>如何触发RDB快照:                     
 save或bgsave命令会触发rdb快照。                     
 save时只管保存，其它不管，全部阻塞;使用bgsave命令时edis会在后台异步进行快照操作，快照同时还可以响应客户端请求。                
 可以通过lastsave命令获取最后一次成功执行快照的时间。                 
 执行flushall命令，也会产生dump.rdb文件，但里面是空的，无意义。                    
 如何恢复：将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可。               
 config get dir获取目录                 
>                       
>优势:                    
 适合大规模的数据恢复                 
 单独创建（fork）一个子进程来进行持久化，父进程不需要做其他IO操作，RDB方式可以最大化redis的性能                 
 对数据完整性和一致性要求不高                 
 劣势:                
 在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改；                  
 Fork的时候，内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑。                 
 停止rdb快照:                   
 动态停止RDB保存规则的方法：redis-cli config set save ""                                
>                           
>AOF以日志的形式来记录每个写操作，将Redis执行过的所有写指令记录下来(读操作不记录)。只许追加文件但不可以改写文件，redis启动之初会读取该文件重新构建数据。                    
 redis重启的话就根据日志文件的内容将写指令从前到后执行一次以完成数据的恢复工作              
 aof保存的是appendonly.aof文件                
>                           
>配置位置:                  
 appendonly no                  
 appendfilename "appendonly.aof"                
>                       
>appendfsync:                   
 always:同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好               
 everysec:出厂默认推荐，异步操作，每秒记录 如果一秒内宕机，有数据丢失                    
 no：从不同步                
>                                              
>aof的启动、修复、恢复：                      
 正常恢复：                  
 修改默认的appendonly no，改为yes即启动aof持久化；             
 将有数据的aof文件复制一份保存到对应目录(config get dir)；                 
 重启redis然后重新加载appendonly.aof文件，完成恢复。            
 异常恢复：              
 修改默认的appendonly no，改为yes即启动aof持久化；             
 备份appendonly.aof文件；                
 运行redis-check-aof --fix appendonly.aof命令进行数据修复；                                
 重启redis然后重新加载appendonly.aof文件，完成恢复。   
>                                        
>rewrite:                         
 aof采用文件追加方式，文件会越来越大为避免出现此种情况，新增了重写机制,当aof文件的大小超过所设定的阈值时，redis就会启动aof文件的内容压缩，只保留可以恢复数据的最小指令集.               
 命令bgrewriteaof用于手动触发重写操作。即使bgrewriteaof执行失败，也不会有任何数据丢失，因为旧的aof文件在bgrewriteaof成功之前不会被修改。                
 重写原理:aof文件持续增长而过大时，会fork出一条新进程来将文件重写(也是先写临时文件最后再rename)，遍历新进程的内存中数据，每条记录有一条的set语句。             
 重写aof文件的操作，并没有读取旧的aof文件，而是将整个内存中的数据库内容用命令的方式重写了一个新的aof文件，这点和快照有点类似。                    
 触发机制:redis会记录上次重写时的aof大小，默认配置是当aof文件大小是上次rewrite后大小的一倍且文件大于64M时触发。                     
>                           
>优势：                
 每修改同步：appendfsync always 同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好         
 每秒同步：appendfsync everysec 异步操作，每秒记录 如果一秒内宕机，有数据丢失              
 不同步：appendfsync no 从不同步                    
 劣势：aof运行效率要慢于rdb,每秒同步策略效率较好，不同步效率和rdb相同
>                                       
>rdb和aof持久化选择哪一个？               
 只做缓存时可以不使用任何持久化方式。                 
 rdb文件只用作后备用途，建议只在slave上持久化rdb文件，而且只要15分钟备份一次就够了，只保留save 900 1这条规则。             
 同时开启两种持久化方式：                   
 在这种情况下,当redis重启的时候会优先载入aof文件来恢复原始的数据,因为在通常情况下aof文件保存的数据集要比RDB文件保存的数据集要完整。
 rdb的数据不实时，同时使用两者时服务器重启也只会找aof文件。那要不要只使用aof呢？建议不要，因为rdb更适合用于备份数据库(aof在不断变化不好备份)，
 快速重启，而且不会有aof可能潜在的bug，留着作为一个万一的手段。                     
## 11.Pipeline有什么好处，为什么要用pipeline？
>pipeline的作用是将一批命令进行打包，然后发送给服务器，服务器执行完按顺序打包返回。          
 通过pipeline，一次pipeline（n条命令）=一次网络时间 + n次命令时间            
 pipeline可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。               
 pipeline注意事项:              
 每次pipeline携带数量不推荐过大，否则会影响网络性能              
 pipeline每次只能作用在一个Redis节点上              
## 12.Redis的同步机制？
>为了避免服务的单点故障，会把数据复制到多个副本放在不同的服务器上，且这些拥有数据副本的服务器可以用于处理客户端的读请求，扩展整体的性能。           
 Redis支持主从复制，Redis的主从结构可以采用一主多从或者级联结构，Redis主从复制分为全量同步和增量同步。             
>               
>全量同步                             
 Redis全量复制一般发生在Slave初始化阶段，这时Slave需要将Master上的所有数据都复制一份。具体步骤如下：               
 (1).从服务器连接主服务器，发送SYNC命令；               
 (2).主服务器接收到SYNC命名后，开始执行BGSAVE命令生成RDB文件并使用缓冲区记录此后执行的所有写命令；              
 (3).主服务器BGSAVE执行完后，向所有从服务器发送快照文件，并在发送期间继续记录被执行的写命令；                
 (4).从服务器收到快照文件后丢弃所有旧数据，载入收到的快照；                
 (5).主服务器快照发送完毕后开始向从服务器发送缓冲区中的写命令；              
 (6).从服务器完成对快照的载入，开始接收命令请求，并执行来自主服务器缓冲区的写命令；                
> ![redis](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis.png)              
>完成上面几个步骤后就完成了从服务器数据初始化的所有操作，从服务器此时可以接收来自用户的读请求。                
>               
>增量同步                                  
 Redis增量复制是指Slave初始化后开始正常工作时主服务器发生的写操作同步到从服务器的过程。                                 
 增量复制的过程主要是主服务器每执行一个写命令就会向从服务器发送相同的写命令，从服务器接收并执行收到的写命令。             
>               
>主从复制的特点：               
 (1).采用异步复制；                    
 (2).一个主redis可以含有多个从redis；              
 (3).每个从redis可以接收来自其他从redis服务器的连接；          
 (4).主从复制对于主redis服务器来说是非阻塞的，这意味着当从服务器在进行主从复制同步过程中，主redis仍然可以处理外界的访问请求；              
 (5).主从复制对于从redis服务器来说也是非阻塞的，这意味着，即使从redis在进行主从复制过程中也可以接受外界的查询请求，
>只不过这时候从redis返回的是以前老的数据，如果你不想这样，那么在启动redis时，可以在配置文件中进行设置，那么从redis
>在复制同步过程中来自外界的查询请求都会返回错误给客户端；（虽然说主从复制过程中对于从redis是非阻塞的，但是当从redis
>从主redis同步过来最新的数据后还需要将新数据加载到内存中，在加载到内存的过程中是阻塞的，在这段时间内的请求将会被阻，
>但是即使对于大数据集，加载到内存的时间也是比较多的）；                    
 (6).主从复制提高了redis服务的扩展性，避免单个redis服务器的读写访问压力过大的问题，同时也可以给为数据备份及冗余提供一种解决方案；                
 (7).为了减少主redis服务器写磁盘压力带来的开销，可以配置让主redis不在将数据持久化到磁盘，而是通过连接让一个配置的从redis服务器及时的将相关
>数据持久化到磁盘，不过这样会存在一个问题，就是主redis服务器一旦重启，因为主redis服务器数据为空，这时候通过主从同步可能导致从redis服务器上的数据也被清空。               
>                               
>部分同步:              
 从redis 2.8版本以前，并不支持部分同步，当主从服务器之间的连接断掉之后，master服务器和slave服务器之间都是进行全量数据同步，
>但是从redis 2.8开始，即使主从连接中途断掉，也不需要进行全量同步。部分同步的实现依赖于在master服务器内存中给每个slave服务器
>维护了一份同步日志和同步标识，每个slave服务器在跟master服务器进行同步时都会携带自己的同步标识和上次同步的最后位置。当主从连
>接断掉之后，slave服务器隔断时间（默认1s）主动尝试和master服务器进行连接，如果从服务器携带的偏移量标识还在master服务器上的
>同步备份日志中，那么就从slave发送的偏移量开始继续上次的同步操作，如果slave发送的偏移量已经不再master的同步备份日志中（可能
>由于主从之间断掉的时间比较长或者在断掉的短暂时间内master服务器接收到大量的写操作），则必须进行一次全量更新。在部分同步过程中，
>master会将本地记录的同步备份日志中记录的指令依次发送给slave服务器从而达到数据一致。                    
>               
>主从复制的好处：                   
 数据冗余，实现数据的热备份                  
 故障恢复，避免单点故障带来的服务不可用                
 读写分离，负载均衡。主节点负载读写，从节点负责读，提高服务器并发量              
 高可用基础，是哨兵机制和集群实现的基础                                  
>                                          
>一主多从:一个master可以有多个slave            
>查看机器主从复制情况的命令：info replication                                        
>slaveof ip port                
 问:切入点问题：slave1、slave2是从头开始复制还是从切入点开始复制?比如从k4进来，那之前的k1、k2、k3是否也可以复制？          
 答:从头开始复制                     
 问:从机是否可以写？set可否？             
 答:从机不可写              
 问:主机shutdown后情况如何？从机是上位还是原地待命？               
 答:原地待命               
 问:主机又回来了后，主机新增记录，从机还能否顺利复制？              
 答:能              
 问:其中一台从机down后情况如何？依照原有它能跟上大部队吗？                  
 答:不能，每次与master断开之后，都需要重新连接，除非你配置进redis.conf文件。               
>                                   
>级联结构(薪火相传)                     
>上一个slave可以是下一个slave的master，slave同样可以接收其他slaves的连接和同步请求，那么该slave作为了链条中下一个的master,可以有效减轻master的写压力。                  
 中途变更转向:会清除之前的数据，重新建立拷贝最新的。slaveof 新主库IP 新主库端口                  
>                   
>哨兵模式(sentinel)                 
>哨兵模式是一种特殊的模式，它是Redis高可用的一种实现方案。哨兵是一个独立的Redis服务端进程， 可以实现对Redis实例的监控、通知、自动故障转移、配置提供。                                   
>监控(Monitoring)：哨兵(sentinel) 会不断地检查你的 Master 和 Slave 是否运作正常。                
 提醒(Notification)：当被监控的某个 Redis 出现问题时, 哨兵(sentinel) 可以通过 API 向管理员或者其他应用程序发送通知。          
 自动故障迁移(Automatic failover)：当一个Master不能正常工作时，哨兵(sentinel) 会开始一次自动故障迁移操作,
>它会将失效Master的其中一个Slave升级为新的Master, 并让失效Master的其他Slave改为复制新的Master; 当客户端试图连接失效的
>Master时,集群也会向客户端返回新Master的地址,使得集群可以使用Master代替失效Master。                             
>配置提供（Configuration provider）：客户端可以把 Sentinel 作为权威的配置发布者来获得最新的master地址。如果发生了故障转移，
>Sentinel集群会通知客户端新的 master 地址，并刷新 Redis 的配置。       
>               
>定时任务：每个哨兵节点维护了3个定时任务。定时任务的功能分别如下：通过向主从节点发送info命令获取最新的主从结构；
>通过发布订阅功能获取其他哨兵节点的信息；通过向其他节点发送ping命令进行心跳检测，判断是否下线。                  
 主观下线：在心跳检测的定时任务中，如果其他节点超过一定时间没有回复，哨兵节点就会将其进行主观下线。
>顾名思义，主观下线的意思是一个哨兵节点“主观地”判断下线；与主观下线相对应的是客观下线。           
 客观下线：哨兵节点在对主节点进行主观下线后，会通过sentinel is-master-down-by-addr命令询问其他哨兵节点该主节点的状态；
>如果判断主节点下线的哨兵数量达到一定数值，则对该主节点进行客观下线。             
 需要特别注意的是，客观下线是主节点才有的概念；如果从节点和哨兵节点发生故障，被哨兵主观下线后，不会再有后续的客观下线和故障转移操作。         
 选举领导者哨兵节点：当主节点被判断客观下线以后，各个哨兵节点会进行协商，选举出一个领导者哨兵节点，并由该领导者节点对其进行故障转移操作。
 监视该主节点的所有哨兵都有可能被选为领导者，选举使用的算法是Raft算法；Raft算法的基本思路是先到先得：即在一轮选举中，哨兵A向B发送成为领导者的申请
>，如果B没有同意过其他哨兵，则会同意A成为领导者。一般来说，哨兵选择的过程很快，谁先完成客观下线，一般就能成为领导者。            
 故障转移：选举出的领导者哨兵，开始进行故障转移操作，该操作大体可以分为3个步骤：                           
 在从节点中选择新的主节点：选择的原则是，首先过滤掉不健康的从节点；然后选择优先级最高的从节点(由slave-priority指定)；
>如果优先级无法区分，则选择复制偏移量最大的从节点；如果仍无法区分，则选择runid最小的从节点。
 更新主从状态：通过slaveof no one命令，让选出来的从节点成为主节点；并通过slaveof命令让其他节点成为其从节点。       
>           
>Sentinel缺陷:            
 Sentinel模式下，写操作仍然只能在Sentinel提供的master数据节点上执行，无法负载均衡                
 持久化时master节点刷盘阻塞，服务请求成功率下降             
 slave节点存储能力受到单机的限制         
 分区问题:原master redis3断开与redis1和redis2的连接，此时redis1和redis2执行故障转移，选择redis1为master。
>这时，redis1和redis3都能接受写请求，但数据无法同步，数据不一致。                                                                               
## 13.Redis集群的高可用怎么保证，集群的原理是什么？
>分布式系统（distributed system）              
 由多台计算机和通信的软件组件通过计算机网络连接（本地网络或广域网）组成。分布式系统是建立在网络之上的软件系统。正是因为软件的特性，
>所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。
>分布式系统可以应用在不同的平台上如：PC、工作站、局域网和广域网上等。                    
 分布式:不同的多台服务器上面部署不同的服务模块（工程），他们之间通过Rpc/Rmi之间通信和调用，对外提供服务和组内协作。              
 集群:不同的多台服务器上面部署相同的服务模块，通过分布式调度软件进行统一的调度，对外提供服务和访问。                    
>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。
 Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。
## 14.NoSQL数据库的分类？
>KV键值：memcache redis                    
 文档型数据库(bson格式比较多)：MongoDB              
 列存储数据库                         
 图关系数据库                     
## 15.CAP理论
>CAP：Consistency（强一致性） Availability（可用性） Partition tolerance（分区容错性）                     
 CAP理论就是说在分布式存储系统中，最多只能实现上面的两点。由于当前的网络硬件肯定会出现延迟丢包等问题，所以分区容忍性是必须需要实现的。                    
 只能在一致性和可用性之间进行权衡， 没有NoSQL系统能同时保证这三点。                               
 C:强一致性(所有节点在同一时间具有相同的数据)                       
>A:高可用性(保证每个请求不管成功或者失败都有响应)                           
>P:分布式容忍性(系统中任意信息的丢失或失败不会影响系统的继续运作)                                        
 注意：分布式架构的时候必须做出取舍。             
 一致性和可用性之间取一个平衡。大多数web应用，其实并不需要强一致性。 因此牺牲C换取P，这是目前分布式数据库产品的方向。              
 CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。               
 因此，根据 CAP 原理将 NoSQL 数据库分成了满足CA原则、满足CP原则和满足AP原则三 大类：                    
 CA:单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。RDMS                 
 CP:满足一致性，分区容忍性的系统，通常性能不是特别高。MongoDB,Redis,HBase                    
 AP:满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。大多数网站架构的选择。CouchDB,Cassandra,DynamoDB,Riak                              
## 16.BASE理论
>CAP理论的核心是:一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。               
 BASE是NoSQL数据库通常对可用性及一致性的弱要求原则:                 
 基本可用(Basically Available)              
 软状态/柔性事务(Soft State) "Soft state" 可以理解为"无连接"的, 而 "Hard state" 是"面向连接"的         
 最终一致性(Eventually Consistency), 也是 ACID 的最终目的。              
 它的思想是通过让系统放松对某一时刻数据一致性的要求来换取系统整体伸缩性和性能上改观。大型系统往往由于地域分布和极高性能的要求，
>不可能采用分布式事务来完成这些指标，要想获得这些指标，必须采用另外一种方式来完成，这里BASE就是解决这个问题的办法。                
## 17.Redis和Memcached的区别？
>Redis和Memcache都是将数据存放在内存中，都是内存数据库。                             
 两者的主要区别:                       
 (1).支持的数据类型不同                  
 Redis支持的数据类型丰富,不仅支持简单的k/v类型的数据，同时还提供String，List,Set,Hash,Sorted Set,pub/sub,Transactions数据结构的存储。                       
 memcache支持简单数据类型，需要客户端自己处理复杂对象。不过memcache还可用于缓存图片、视频等其他东西。                         
 (2).对持久性的支持不同                  
 redis支持数据落地持久化存储,可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。                  
 memcache不支持数据持久存储。                 
 (3).扩展性的实现方式(分布式存储)不同                  
 redis支持master-slave复制模式                        
 memcached本身并不支持分布式，只能在客户端通过像一致性哈希这样的分布式算法来实现memcached的分布式存储。               
 (4).性能不同               
 由于Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，
>Memcached性能要高于Redis，虽然Redis也在存储大数据的性能上进行了优化，但是比起Memcached，还是稍有逊色。                  
 (5).存储数据安全性不同                      
 redis中的数据可以定期保存到磁盘（持久化，redis挂掉后，数据可以通过aof、rdb恢复                        
 memcache挂掉后，数据没了，数据不可恢复                    
 (6).过期策略不同                     
 redis在set的时候可以不指定，然后通过expire设定，例如expire name 10                        
 memcache在set时就指定，例如set key1 0 0 8,即永不过期                        
## 18.单线程的redis为什么这么快
>Redis到底有多快:                            
>redis性能卓越,作为key-value系统最大负载数量级为10W/s,set和get耗时数量级为10ms和5ms。使用流水线的方式可以提升redis操作的性能。                     
>                                   
>Redis为什么那么快:                                      
>内存存储：Redis是使用内存(in-memeroy)存储,没有磁盘IO上的开销                                  
 单线程实现：Redis使用单个线程处理请求，避免了多个线程之间线程切换和锁资源争用的开销                                  
 非阻塞IO：Redis使用多路复用IO技术，在poll，epool，kqueue选择最优IO实现                             
 优化的数据结构：Redis有诸多可以直接应用的优化数据结构的实现，应用层可以直接使用原生的数据结构提升性能                                        
>参考 https://segmentfault.com/a/1190000022088928             
## 19.redis的过期策略以及内存淘汰机制
>缓存是指在第一次获取到数据时，把它暂存在内存中。下次需要这个数据时，就直接从内存中取，不用再去查询数据库或调用远程接口，这样可以极大地提高应用程序的性能。                  
 如果缓存中的数据永久存在，那占用的内存就会变得越来越大。而内存是有限的，所以缓存系统需要在需要的时候删除一些不必要的缓存数据以节约内存空间。                 
 Redis提供了过期策略和内存淘汰这两种机制配合来达到删除一些不必要的缓存数据以节约内存空间目的。                  
>               
>Redis是使用定期删除+惰性删除两者配合的过期策略。                
 定期删除是指Redis默认每隔100ms就随机抽取一些设置了过期时间的key，检测这些key是否过期，如果过期了就将其删掉。                     
 因为key太多，如果全盘扫描所有的key会非常耗性能，所以是随机抽取一些key来删除。这样就有可能删除不完，需要惰性删除配合。                    
 惰性删除不再是Redis去主动删除，而是在客户端要获取某个key的时候，Redis会先去检测一下这个key是否已经过期，如果没有过期则返回给客户端，
>如果已经过期了，那么Redis会删除这个key，不会返回给客户端。              
 所以惰性删除可以解决一些过期了，但没被定期删除随机抽取到的key。但有些过期的key既没有被随机抽取，也没有被客户端访问，就会一直保留在数据库，
>占用内存，长期下去可能会导致内存耗尽。所以Redis提供了内存淘汰机制来解决这个问题。                            
>                               
>为什么不使用定时删除？                            
 所谓定时删除，指的是用一个定时器来负责监视key，当这个key过期就自动删除，虽然内存及时释放，但是十分消耗CPU资源，因此一般不推荐采用这一策略。                         
>                               
>内存淘汰机制                             
 Redis在使用内存达到某个阈值时（通过maxmemory配置)，就会触发内存淘汰机制，选取一些key来删除。                        
># maxmemory <bytes> 配置内存阈值                             
># maxmemory-policy allkeys-lru                                         
>内存淘汰策略:                    
 noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。默认策略                    
 allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。                             
 allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。                                     
 volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。                            
 volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。                        
 volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。                                 
>                           
>如何选取合适的策略？                                 
 比较推荐的是两种lru策略。根据自己的业务需求。如果你使用Redis只是作为缓存，不作为DB持久化，那推荐选择allkeys-lru；
>如果你使用Redis同时用于缓存和数据持久化，那推荐选择volatile-lru。                              
 如果没有设置expire的key, 不满足先决条件(prerequisites); 那么 volatile-lru, volatile-random 和 volatile-ttl 策略的行为, 和 noeviction(不删除) 基本上一致。                      
## 20.使用redis的缺点?
>(1).缓存和数据库双写一致性问题
>一致性问题分为最终一致性和强一致性。数据库和缓存双写，就必然会存在不一致的问题。如果对数据有强一致性要求，就不能放缓存。
>数据库和缓存双写只能保证最终一致性。其实从根本上来说，只能说降低不一致发生的概率，无法完全避免。因此，有强一致性要求的数据，不能放缓存。   
>                                                                                                  
>从理论上来说，给缓存设置过期时间，是保证最终一致性的解决方案。这种方案下，可以对存入缓存的数据设置过期时间，所有的写操作以数据库为准，
>对缓存操作只是尽最大努力即可。也就是说如果数据库写成功，缓存更新失败，那么只要到达过期时间，则后面的读请求自然会从数据库中读取新值然后回填缓存。                   
>                       
>为保证redis和数据库双写一致性问题，首先采取正确更新策略，先更新数据库，再删缓存。其次，因为可能存在删除缓存失败的问题，提供一个补偿措施即可，例如利用消息队列。                         
>                       
>先更新数据库，再更新缓存是普遍反对的。                    
 两点原因:                  
 原因一（线程安全角度）                    
 同时有请求A和请求B进行更新操作，那么会出现                 
 a.线程A更新了数据库                    
 b.线程B更新了数据库                
 c.线程B更新了缓存             
 d.线程A更新了缓存                     
 这就出现请求A更新缓存应该比请求B更新缓存早才对，但是因为网络等原因，B却比A更早更新了缓存。这就导致了脏数据，因此不考虑。                 
 原因二（业务场景角度）                    
 a.如果是一个写数据库场景比较多，而读数据场景比较少的业务需求，采用这种方案就会导致，数据压根还没读到，缓存就被频繁的更新，浪费性能。                
 b.如果写入数据库的值，并不是直接写入缓存的，而是要经过一系列复杂的计算再写入缓存。那么，每次写入数据库后，都再次计算写入缓存的值，无疑是浪费性能的。显然，删除缓存更为适合。                    
>                               
>接下来讨论的就是争议最大的，先删缓存，再更新数据库。还是先更新数据库，再删缓存的问题。                
>先删缓存，再更新数据库导致不一致的原因是:同时有一个请求A进行更新操作，另一个请求B进行查询操作。那么会出现如下情形:                    
 a.请求A进行写操作，删除缓存                
 b.请求B查询发现缓存不存在         
 c.请求B去数据库查询得到旧值            
 d.请求B将旧值写入缓存           
 e.请求A将新值写入数据库                  
 上述情况就会导致不一致的情形出现。而且，如果不采用给缓存设置过期时间策略，该数据永远都是脏数据。               
>                   
>如何解决呢？             
 采用延时双删策略               
 a.先淘汰缓存                
 b.再写数据库（这和原来一样）                
 c.休眠1秒，再次淘汰缓存              
 这么做，可以将1秒内所造成的缓存脏数据，再次删除。              
 这个1秒怎么确定的，具体该休眠多久呢？                    
 针对上面的情形，开发者应该自行评估自己的项目的读数据业务逻辑的耗时。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上，加几百ms即可。
>这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。                   
 如果用了mysql的读写分离架构造成数据不一致的原因如下：还是两个请求，一个请求A进行更新操作，另一个请求B进行查询操作。              
 a.请求A进行写操作，删除缓存                    
 b.请求A将数据写入数据库了                     
 c.请求B查询缓存发现，缓存没有值                  
 d.请求B去从库查询，这时，还没有完成主从同步，因此查询到的是旧值                  
 e.请求B将旧值写入缓存               
 f.数据库完成主从同步，从库变为新值             
 上述情形还是使用双删延时策略。只是睡眠时间修改为在主从同步的延时时间基础上，加几百ms。           
>                   
>采用这种同步淘汰策略，吞吐量降低怎么办？                   
 将第二次删除作为异步的。自己起一个线程，异步删除。这样，写的请求就不用沉睡一段时间后了，再返回。这么做，加大吞吐量。             
 第二次删除,如果删除失败怎么办？               
 这是个非常好的问题，因为第二次删除失败，就会出现如下情形。还是有两个请求，一个请求A进行更新操作，另一个请求B进行查询操作，为了方便，假设是单库：                      
 a.请求A进行写操作，删除缓存                        
 b.请求B查询发现缓存不存在                     
 c.请求B去数据库查询得到旧值                        
 d.请求B将旧值写入缓存                   
 e.请求A将新值写入数据库              
 f.请求A试图去删除请求B写入对缓存值，结果失败了。                     
>                   
>如果第二次删除缓存失败，会再次出现缓存和数据库不一致的问题。                             
 如何解决呢？                     
 提供一个保障的重试机制:                   
 a.更新数据库数据；                     
 b.缓存因为种种问题删除失败                 
 c.将需要删除的key发送至消息队列             
 d.自己消费消息，获得需要删除的key                
 e.继续重试删除操作，直到成功
> ![redis2](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis2.png)              
>该方案有一个缺点，对业务线代码造成大量的侵入。                    
 于是有了方案二:启动一个订阅程序去订阅数据库的binlog，获得需要操作的数据。在应用程序中，另起一段程序，获得这个订阅程序传来的信息，进行删除缓存操作。              
> ![redis3](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis3.png)              
>流程如下：              
 a.更新数据库数据              
 b.数据库会将操作信息写入binlog日志当中                
 c.订阅程序提取出所需要的数据以及key               
 d.另起一段非业务代码，获得该信息              
 e.尝试删除缓存操作，发现删除失败              
 f.将这些信息发送至消息队列             
 g.重新从消息队列中获得该数据，重试操作               
 订阅binlog程序在mysql中有现成的中间件叫canal，可以完成订阅binlog日志的功能
> 参考 https://www.cnblogs.com/rjzheng/p/9041659.html                                                                                           
>                                                                                     
>(2).缓存穿透问题
>缓存穿透是指用户请求的数据在缓存中不存在即没有命中，同时在数据库中也不存在，导致用户每次请求该数据都要去数据库中查询一遍。
>如果有恶意攻击者不断请求系统中不存在的数据，会导致短时间大量请求落在数据库上，造成数据库压力过大，甚至导致数据库承受不住而宕机崩溃。                     
 解决方法：              
 a.将无效的key存放进Redis中：                        
 当出现Redis查不到数据，数据库也查不到数据的情况，就把这个key保存到Redis中，设置value="null"，并设置其过期时间极短，后面再出现查询这个key
>的请求的时候，直接返回null，就不需要再查询数据库了。但这种处理方式是有问题的，假如传进来的这个不存在的Key值每次都是随机的，那存进Redis也没有意义。                        
 b.使用布隆过滤器：                 
 如果布隆过滤器判定某个key不存在布隆过滤器中，那么就一定不存在，如果判定某个 key 存在，那么很大可能是存在(存在一定的误判率)。
>于是可以在缓存之前再加一个布隆过滤器，将数据库中的所有key都存储在布隆过滤器中，在查询Redis前先去布隆过滤器查询key是否存在，
>如果不存在就直接返回，不让其访问数据库，从而避免了对底层存储系统的查询压力。 
> ![redis4](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis4.png)              
>如何选择：                          
 针对一些恶意攻击，攻击带过来的大量key是随机，那么采用a方案就会缓存大量不存在key的数据。那么这种方案就不合适了，
>可以先对使用布隆过滤器方案进行过滤掉这些key。所以，针对这种key异常多、请求重复率比较低的数据，优先使用第二种方案直接过滤掉。
>而对于空数据的key有限的，重复率比较高的，则可优先采用第一种方式进行缓存。                         
>                   
>(3).缓存雪崩问题
>如果缓在某一个时刻出现大规模的key失效，那么就会导致大量的请求打在了数据库上，导致数据库压力巨大，如果在高并发的情况下，
>可能瞬间就会导致数据库宕机。这时候如果运维马上又重启数据库，马上又会有新的流量把数据库打死。这就是缓存雪崩。             
 造成缓存雪崩的关键在于同一时间的大规模的key失效，为什么会出现这个问题，主要有两种可能：第一种是Redis宕机，第二种可能就是采用了相同的过期时间。                    
 解决方案：              
 [1].事前：                
 a.均匀过期：设置不同的过期时间，让缓存失效的时间尽量均匀，避免相同的过期时间导致缓存雪崩，造成大量数据库的访问。              
 b.分级缓存：第一级缓存失效的基础上，访问二级缓存，每一级缓存的失效时间都不同。               
 c. 热点数据缓存永远不过期。                
 永不过期实际包含两层意思：                  
 物理不过期，针对热点key不设置过期时间                   
 逻辑过期，把过期时间存在key对应的value里，如果发现要过期了，通过一个后台的异步线程进行缓存的构建           
 d.保证Redis缓存的高可用，防止Redis宕机导致缓存雪崩的问题。可以使用 主从+ 哨兵，Redis集群来避免 Redis 全盘崩溃的情况。           
 [2].事中：            
 a.互斥锁：在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，
>其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降                    
 b.使用熔断机制，限流降级。当流量达到一定的阈值，直接返回“系统拥挤”之类的提示，防止过多的请求打在数据库上将数据库击垮，
>至少能保证一部分用户是可以正常使用，其他用户多刷新几次也能得到结果。                 
 [3].事后：                            
 开启Redis持久化机制，尽快恢复缓存数据，一旦重启，就能从磁盘上自动加载数据恢复内存中的数据。                                                
>                                      
>(4).缓存击穿问题                 
>缓存击穿跟缓存雪崩有点类似，缓存雪崩是大规模的key失效，而缓存击穿是某个热点的key失效，大并发集中对其进行请求，
>就会造成大量请求读缓存没读到数据，从而导致高并发访问数据库，引起数据库压力剧增。这种现象就叫做缓存击穿。                   
 关键在于某个热点的key失效了，导致大并发集中打在数据库上。所以要从两个方面解决，第一是否可以考虑热点key不设置过期时间，第二是否可以考虑降低打在数据库上的请求数量。                   
 解决方案：                  
 a.热点数据缓存永远不过期。                 
 b.在缓存失效后，通过互斥锁或者队列来控制读数据写缓存的线程数量，比如某个key只允许一个线程查询数据和写缓存，其他线程等待。这种方式会阻塞其他的线程，此时系统的吞吐量会下降。               
> 参考 https://blog.csdn.net/a745233700/article/details/88088669                                 
>                                   
>(5).如何解决redis的并发竞争key问题(有多个子系统去set一个key)                               
[1].如果对这个key操作不要求顺序,则准备一个分布式锁，多个子系统去抢锁，抢到锁就做set操作即可。                                                
[2].如果对这个key操作要求顺序。假设有一个key1,系统A需要将key1设置为valueA,系统B需要将key1设置为valueB,系统C需要将key1设置为valueC。               
期望按照key1的value值按照 valueA-->valueB-->valueC的顺序变化。                                                     
a.利用队列，将set方法变成串行访问。                                                                       
b.保存一个时间戳。假设时间戳如下:                                      
系统A key1 {valueA  3:00}                                                      
系统B key1 {valueB  3:05}                                            
系统C key1 {valueC  3:10}                                                    
那么，假设这会系统B先抢到锁，将key1设置为{valueB 3:05}。接下来系统A抢到锁，发现自己的valueA的时间戳早于缓存中的时间戳，那就不做set操作了。以此类推。                                     
>                       
>乐观锁不要在分片集群中使用 
## 21.缓存预热
>缓存预热是指系统上线后，提前将相关的缓存数据加载到缓存系统。避免在用户请求的时候，先查询数据库，然后再将数据缓存的问题，用户直接查询事先被预热的缓存数据。                  
 如果不进行预热，那么Redis初始状态数据为空，系统上线初期，对于高并发的流量，都会访问到数据库中， 对数据库造成流量的压力。                    
 缓存预热解决方案：              
 a.数据量不大的时候，工程启动的时候进行加载缓存动作；                    
 b.数据量大的时候，设置一个定时任务脚本，进行缓存的刷新；                      
 c.数据量太大的时候，优先保证热点数据进行提前加载到缓存。                                       
## 22.缓存降级
>缓存降级是指缓存失效或缓存服务器挂掉的情况下，不去访问数据库，直接返回默认数据或访问服务的内存数据。降级一般是有损的操作，所以尽量减少降级对于业务的影响程度。                            
 在项目实战中通常会将部分热点数据缓存到服务的内存中，这样一旦缓存出现异常，可以直接使用服务的内存数据，从而避免数据库遭受巨大压力。                                            
## 23.布隆过滤器
>布隆过滤器(Bloom Filter)是由一个固定大小的二进制向量或者位图（bitmap）和一系列映射函数组成的。布隆过滤器可以用于检索一个元素是否在一个集合中。              
 原理:当一个元素被加入集合时，通过K个散列函数将这个元素映射成一个位数组中的K个点，把它们置为1。检索时只要看看这些点是不是都是1就大约知道集合中有没有它了,
>如果这些点有任何一个0，则被检元素一定不在；如果都是1，则被检元素很可能在。                             
 优点:空间效率和查询时间都远远超过一般的算法
 缺点:            
 有一定的误识别率:可能要查到的元素并没有在容器中，但是hash之后得到的k个位置上值都是1。如果bloom filter中存储的是黑名单，那么可以通过建立一个白名单来存储可能会误判的元素。                     
 删除困难:一个放入容器的元素映射到bit数组的k个位置上是1，删除的时候不能简单的直接置为0，可能会影响其他元素的判断。               
 特性:                
 [1].一个元素如果判断结果为存在的时候元素不一定存在，但是判断结果为不存在的时候则一定不存在。               
 [2].布隆过滤器可以添加元素，但是不能删除元素。因为删掉元素会导致误判率增加。           
 添加与查询元素步骤:             
 [1].添加元素               
 a.将要添加的元素给k个哈希函数                 
 b.得到对应于位数组上的k个位置                   
 c.将这k个位置设为1                
 [2].查询元素               
 a.将要查询的元素给k个哈希函数                   
 b.得到对应于位数组上的k个位置               
 c.如果k个位置有一个为 0，则肯定不在集合中                    
 d.如果k个位置全部为 1，则可能在集合中              
 布隆过滤器的典型应用有：                   
 [1].数据库防止穿库。使用BloomFilter来减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。                   
 [2].业务场景中判断用户是否阅读过某视频或文章，比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。                 
 [3].缓存宕机、缓存击穿场景，一般判断用户是否在缓存中，如果在则直接返回结果，不在则查询db，如果来一波冷数据，会导致缓存大量击穿，造成雪崩效应，
>这时候可以用布隆过滤器当缓存的索引，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。               
 [4].WEB拦截器，如果相同请求则拦截，防止重复被攻击。用户第一次请求，将请求参数放入布隆过滤器中，当第二次请求时，先判断请求参数是否被布隆过滤器命中。
>可以提高缓存命中率。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务                     
 [5].Venti文档存储系统也采用布隆过滤器来检测先前存储的数据。                          
 [6].SPIN模型检测器也使用布隆过滤器在大规模验证问题时跟踪可达状态空间。                            
## 24.跳跃表    
> 跳跃表(Skip List)是一个可以在有序元素中实现快速查询的数据结构，其插入，查找，删除操作的平均效率都为O(logn)。               
  跳跃表以有序的方式在层次化的链表中保存元素,整体性能可以和二叉查找树(平衡树，红黑树等)相媲美，其在Redis和LevelDB中都有广泛的应用。              
>有序单链表的每个元素存放下一个元素的引用。通过第一个元素可以找到第二个元素，通过第二个元素可以找到第三个元素，依次类推，直到找到最后一个元素。平均时间复杂度很高O(n)。              
>                       
>跳跃表是从有序单链表中每两个元素抽出来，选n/2个元素做为一级索引，一级索引指向了原始链表,选n/4个元素做为二级索引,二级索引指向一级索引，以此类推，加上logn级索引。
>通过给链表建立索引，用“空间换时间”，使得链表能够实现二分查找，提高了查找的效率。时间复杂度为O(logn)。空间复杂度是 O(n)。            
>                         
>查找数据：                                          
>查找元素的过程是从最高级索引开始，一层一层遍历最后下沉到原始链表。时间复杂度为O(logn)。                        
>               
>插入数据：                      
>实现一个randomLevel()方法，该方法会随机生成1~MAX_LEVEL之间的数（MAX_LEVEL表示索引的最高层数），且该方法有1/2的概率返回1、1/4的概率返回2、1/8的概率返回3，以此类推。               
 randomLevel() 方法返回1 表示当前插入的该元素不需要建索引，只需要存储数据到原始链表即可（概率1/2）                
 randomLevel() 方法返回2 表示当前插入的该元素需要建一级索引（概率1/4）                 
 randomLevel() 方法返回3 表示当前插入的该元素需要建二级索引（概率1/8）                     
 randomLevel() 方法返回4 表示当前插入的该元素需要建三级索引（概率1/16）                    
 元素插入到单链表的时间复杂度为O(1)，索引的高度最多为logn，当插入一个元素x时，最坏的情况就是元素x需要插入到每层索引中，所以插入数据到各层索引中，最坏时间复杂度是O(logn)。              
>                               
>删除数据：                                      
 跳表删除数据时，要把索引中对应节点也要删掉。                     
 删除元素的过程跟查找元素的过程类似，只不过在查找的路径上如果发现了要删除的元素x，则执行删除操作。跳表中，每一层索引其实都是一个有序的单链表，
>单链表删除元素的时间复杂度为O(1)，索引层数为logn,表示最多需要删除logn个元素，所以删除元素的总时间包含查找元素的时间加删除logn个元素的时间,
>为O(logn)+O(logn)=2xO(logn)，删除元素的时间复杂度为O(logn)。                         
>                           
>跳跃表主要由以下部分构成：                  
 表头（head）：负责维护跳跃表的节点指针。                     
 跳跃表节点：保存着元素值，以及多个层。                        
 层：保存着指向其他元素的指针。高层的指针越过的元素数量大于等于低层的指针，为了提高查找的效率，程序总是从高层先开始访问，然后随着元素值范围的缩小，慢慢降低层次。                       
 表尾：全部由 NULL 组成，表示跳跃表的末尾。                   
>                               
>为了满足自身的功能需要， Redis对跳跃表进行了以下修改：                     
 允许重复的 score 值：多个不同的 member 的 score 值可以相同。                  
 进行对比操作时，不仅要检查 score 值，还要检查 member ：当 score 值可以重复时，单靠 score 值无法判断一个元素的身份，所以需要连 member 域都一并检查才行。                 
 每个节点都带有一个高度为 1 层的后退指针，用于从表尾方向向表头方向迭代：当执行 ZREVRANGE 或 ZREVRANGEBYSCORE 这类以逆序处理有序集的命令时，就会用到这个属性。                     
>                           
>跳表的特点:                     
 跳表是可以实现二分查找的有序链表；                          
 每个元素插入时随机生成它的level；                        
 最底层包含所有的元素；                    
 如果一个元素出现在level(x)，那么它肯定出现在x以下的level中；              
 每个索引节点包含两个指针，一个向下，一个向右；                    
 跳表查询、插入、删除的时间复杂度为O(log n)，与平衡二叉树接近。                    
>                                      
> ![redis5](http://github.com/xidianlina/practice/raw/master//redis_practice/picture/redis5.png)                              
## 25.字符串类型值存储最大容量是多少？默认有多少个库？Redis集群之间是如何复制的？Redis集群最大节点个数是多少？
> 字符串类型值存储最大容量是512M                 
>默认有16个库        
>Redis集群之间是异步复制的                
>Redis集群最大节点个数是16384个           
## 26.Redis 如何设置密码及验证密码？
>设置密码： config set requirepass 123456            
>授权密码： auth 123456              
## 27.Redis 集群会有写操作丢失吗？为什么？
>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。 
## 28.MySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据？
>Redis内存数据集大小上升到一定大小的时候， 就会施行数据淘汰策略。 
## 29.Redis最适合的场景？
>a.会话缓存                                         
 用Redis缓存会话(用户的登陆信息，用户的购物车信息)比其他存储(如Memcached)的优势在于:Redis提供持久化。                                  
 b.全页缓存（ FPC）                              
 最快速度加载曾浏览过的页面。                          
 c.队列                           
 Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作， 这使得 Redis 能作为一个很好的消息队列平台来使用。                                  
 d.排行榜/计数器                          
 Redis在内存中对数字进行递增或递减的操作实现的非常好。集合(Set)和有序集合(Sorted Set)使得在执行这些操作的时候变的非常简单。            
 e.发布/订阅                                     
 发布/订阅的使用场景确实非常多。在社交网络连接中使用， 还可作为基于发布/订阅的脚本触发器， 甚至用Redis的发布/订阅功能来建立聊天系统。                        
## 30.关系型数据库跟Redis本质上的区别
>Redis是基于内存的,采用的是单进程单线程模型的KV数据库，由C语言编写，官方提供的数据是可以达到100000+的QPS（每秒内查询次数）。完全基于内存，绝大部分请求是纯粹的内存操作，非常快速。                             
 数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)；                           
 数据结构简单，对数据操作也简单，Redis中的数据结构是专门进行设计的；                   
 采用单线程，避免了不必要的上下文切换和竞争条件，也不存在多进程或者多线程导致的切换而消耗CPU，不用去考虑各种锁的问题，不存在加锁释放锁操作，没有因为可能出现死锁而导致的性能消耗；             
 使用多路I/O复用模型，非阻塞IO；                      
 使用底层模型不同，它们之间底层实现方式以及与客户端之间通信的应用协议不一样，Redis自己构建了VM机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求；                  
 Redis是单线程的，现在服务器都是多核的，那不是很浪费？                
 Redis虽然是单线程的，但是可以通过在单机开多个Redis实例。      
## 31.如何使用 Redis 更节省内存？
>(1).控制key的长度                   
 (2).避免存储bigkey                 
 (3).选择合适的数据类型              
 (4).把Redis当作缓存使用                   
 把Redis它当做缓存来使用，而不是数据库。应用写入到 Redis中的数据，尽可能地都设置过期时间                      
 (5).实例设置maxmemory + 淘汰策略               
 (6).数据压缩后写入Redis                               
 在业务应用中先将数据压缩，再写入到Redis中(例如采用 snappy、gzip 等压缩算法)。                          
 当然，压缩存储的数据，客户端在读取时还需要解压缩，在这期间会消耗更多CPU资源，你需要根据实际情况进行权衡。                                                               