### 19.volatile关键字？           
> JMM定义了原子性，可见性，有序性。                            
> 原子性:在Java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。                        
> 可见性:对于可见性，Java提供了volatile关键字来保证可见性。               
> 当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。             
> 而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因此无法保证可见性。              
> 另外，通过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。               
> 有序性:在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。               
> 在Java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和Lock来保证有序性，很显然，synchronized和Lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然就保证了有序性。                   
>                   
> volatile关键字:                                    
> (1).保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。                                                   
> (2).禁止进行指令重排序。volatile关键字禁止指令重排序有两层意思:当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；                    
> 在其后面的操作肯定还没有进行；在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后面的语句放到其前面执行。                                  
>                                                     
>               
> volatile到底如何保证可见性和禁止指令重排序的?           
> “观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码发现，加入volatile关键字时，会多出一个lock前缀指令”                 
> lock前缀指令实际上相当于一个内存屏障（也成内存栅栏），内存屏障会提供3个功能：                 
> (1).它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障的后面；即在执行到内存屏障这句指令时，在它前面的操作已经全部完成；                    
> (2).它会强制将对缓存的修改操作立即写入主存；              
> (3).如果是写操作，它会导致其他CPU中对应的缓存行无效。                            
>                           
> 使用volatile必须具备以下2个条件：                         
> (1).对变量的写操作不依赖于当前值                    
> (2).该变量没有包含在具有其他变量的不变式中                    
>                       
> 参考 https://www.cnblogs.com/dolphin0520/p/3920373.html
