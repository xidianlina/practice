### 18.多线程锁的升级原理是什么？
>synchronized是通过对象内部的一个叫做监视器锁（monitor）来实现的，监视器锁本质又是依赖于底层的操作系统的Mutex Lock（互斥锁）来实现的。
>而操作系统实现线程之间的切换需要从用户态转换到核心态，这个成本非常高，状态之间的转换需要相对比较长的时间，这就是为什么Synchronized效率低的原因。
>因此，这种依赖于操作系统Mutex Lock所实现的锁我们称之为“重量级锁”。                                
>Java SE 1.6为了减少获得锁和释放锁带来的性能消耗，引入了“偏向锁”和“轻量级锁”：锁一共有4种状态，级别从低到高依次是：无锁状态、偏向锁状态、轻量级锁状态和重量级锁状态。锁可以升级但不能降级。                              
>                                       
> JVM优化synchronized的运行机制，当JVM检测到不同的竞争状态时，就会根据需要自动切换到合适的锁，这种切换就是锁的升级。                
> 在Java中，锁共有4种状态，级别从低到高依次为：无状态锁，偏向锁，轻量级锁和重量级锁状态，这几个状态会随着竞争情况逐渐升级。锁可以升级但不能降级,是不可逆的。                  
> ![lock](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/lock.png)                   
> synchronized可用来给对象和方法或者代码块加锁，当它锁定一个方法或者一个代码块的时候，同一时刻最多只有一个线程执行这段代码。                       
> synchronized有三种应用方式：
> 作用于实例方法，当前实例加锁，进入同步代码前要获得当前实例的锁；                  
  作用于静态方法，当前类加锁，进去同步代码前要获得当前类对象的锁；                  
  作用于代码块，对括号里配置的对象加锁。                   
>                           
> Java对象头                       
  synchronized用的锁存在Java对象头里，Java对象头里的Mark Word默认存储对象的HashCode、分代年龄和锁标记位。
> 在运行期间，Mark Word里存储的数据会随着锁标志位的变化而变化。32位JVM的Mark Word可能变化存储为以下5种数据：                     
> ![lock2](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/lock2.png)                 
>                       
> CAS算法:                
> compareAndSwap，比较并替换，是一种实现并发算法时常用到的技术。CAS需要有3个操作数：内存地址V，旧的预期值A，即将要更新的目标值B；
> 比如你要操作一个变量，他的值为A，你希望将他修改为B，这期间不会进行加锁，当你在修改的时候，你发现值仍旧是A，然后将它修改为B，
> 如果此时值被其他线程修改了，变成了C，那么将不会进行值B的写入操作，这就是CAS的核心理论，通过这样的操作可以实现逻辑上的一种“加锁”，避免了真正去加锁。                         
````java
package com.java.topic.thread;

public class CASTest {
    public final int incrementAndGet() {
        for (; ; ) {                    //自旋
            int current = get();        //旧值
            int next = current + 1;     //新值
            if (compareAndSet(current, next))  //如果旧的预期值与内存中的值一致，那么将新值进行赋值，否则继续自旋
                return next;
        }

    }
}
````                       
>                   
> 偏向锁:偏向锁是JDK1.6中引用的优化，它的目的是消除数据在无竞争情况下的同步原语，进一步提高程序的性能。                       
> 当一个线程访问同步块并获取锁时，会在对象头和栈帧的锁记录里存储偏向的线程ID，以后该线程在进入和退出同步块时不需要进行CAS操作来加锁和解锁，
> 只需测试Mark Word里线程ID是否为当前线程。如果测试成功，表示线程已经获得了锁。如果测试失败，则需要判断偏向锁的标识。
> 如果标识被设置为0（表示当前是无锁状态），则使用CAS竞争锁；如果标识设置成1（表示当前是偏向锁状态），则尝试使用CAS将对象头的偏向锁指向当前线程，
> 触发偏向锁的撤销。偏向锁只有在竞争出现才会释放锁。当其他线程尝试竞争偏向锁时，程序到达全局安全点后（没有正在执行的代码），
> 它会查看Java对象头中记录的线程是否存活，如果没有存活，那么锁对象被重置为无锁状态，其它线程可以竞争将其设置为偏向锁；
> 如果存活，那么立刻查找该线程的栈帧信息，如果还是需要继续持有这个锁对象，那么暂停当前线程，撤销偏向锁，升级为轻量级锁，
> 如果线程不再使用该锁对象，那么将锁对象状态设为无锁状态，重新偏向新的线程。                         
> 偏向锁应用的场景是一个同步代码块只有一个线程频繁访问，使用偏向锁，就不需要频繁使用CAS获取锁和释放锁，
> 只需要简单判断对象头中记录的偏向锁的线程ID是否是当期线程的就可以了，所以偏向锁在这种场景下可以大大提升效率。       
>                   
> 轻量级锁:                     
> 线程在执行同步块之前，如果此对象没有被锁定（锁标志位为“01”状态）,JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头的MarkWord复制到锁记录中，即Displaced Mark Word。
> 然后线程会尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，当前线程获得锁,并且对象的Mark Word标志位转变为“00”，即表示此对象处于轻量级锁定状态。
>                   
> 如果失败，表示其他线程在竞争锁，JVM首先会检查对象的Mark Word是否指向当前线程的栈帧，如果指向当前线程的栈帧说明当前线程已经拥有了这个对象的锁，那就可以直接进入同步块中执行，否则说明这个锁对象已经被其他线程占有了。
> 轻量级锁不再有效，,当前线程使用自旋来获取锁。当自旋次数达到一定次数时，锁就会升级为重量级锁,锁标志变为“10”，Mark Word中存储的就是指向重量级锁的指针，而后面等待的线程也要进入阻塞状态。                   
>               
>只有一个线程进入临界区时使用偏向锁          
>多个线程交替进入临界区时使用轻量级锁             
>多个线程同时进入临界区时使用重量级锁                         
>                                       
> 当线程存在竞争时，偏向锁的效率就会降低，因为当多条线程竞争同一个偏向锁时，会频繁产生偏向锁的撤销，所以此时应该升级为轻量级锁，
> 轻量级锁当线程竞争锁失败时，线程不会阻塞进入自旋，继续获取锁，当竞争非常激烈时，持续自旋而获取不到锁会消耗大量CPU资源，
> 此时就会升级为重量级锁，重量级锁当获取锁失败线程会阻塞，重量级锁的缺点是线程上下文会频繁的切换。          
>                           
> synchronized优化-锁消除:                       
> 消除锁是虚拟机另外一种锁的优化，这种优化更彻底，Java虚拟机在JIT编译时(可以简单理解为当某段代码即将第一次被执行时进行编译，又称即时编译)，
> 通过对运行上下文的扫描，去除不可能存在共享资源竞争的锁，通过这种方式消除没有必要的锁，可以节省毫无意义的请求锁时间。
```java
public class Test extends Thread{
    public static void main(String[] args) {
        contactString("aa", "bb", "cc");
    }
    public static String contactString(String s1, String s2, String s3) {
        return new StringBuffer().append(s1).append(s2).append(s3).toString();
    }
}
```
> StringBuffer的append是一个同步方法，锁就是this也就是(new StringBuilder()),但是在contactString方法中的StringBuffer属于一个局部变量，
> 并且不会被其他线程所使用，因此StringBuffer不可能存在共享资源竞争的情景，JVM会自动将其锁消除。                
>                       
> 自旋锁：              
> 是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，直到获取到锁才会退出循环。                     
> 获取锁的线程一直处于活跃状态，但是并没有执行任何有效的任务，使用这种锁会造成busy-waiting。它是为实现保护共享资源而提出一种锁机制。                           
> 自旋锁与互斥锁比较类似，它们都是为了解决对某项资源的互斥使用。无论是互斥锁，还是自旋锁，在任何时刻，最多只能有一个保持者，
> 也就说，在任何时刻最多只能有一个执行单元获得锁。但是两者在调度机制上略有不同。对于互斥锁，如果资源已经被占用，资源申请者只能进入睡眠状态。
> 但是自旋锁不会引起调用者睡眠，如果自旋锁已经被别的执行单元保持，调用者就一直循环在那里看是否该自旋锁的保持者已经释放了锁，"自旋"一词就是因此而得名。                   
>               
> 锁粗化:                  
  如果虚拟机检测到有这样一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。                                                                          
>                           
> 参考 https://www.cnblogs.com/jxxblogs/p/11890563.html                     
