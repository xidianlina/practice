网络相关
======
## 问题列表
### 1.HTTP资源请求方式有几种？
### 2.http状态码
### 3.get和post请求有哪些区别？
### 4.简述tcp和udp的区别？
### 5.tcp为什么要三次握手，两次不行吗？为什么？
### 6.OSI的七层模型都有哪些？
### 7.forward和redirect的区别？
### 8.如何实现跨域？
### 9.什么是RESTful架构?
### 10.Http和https的区别
### 11.session和cookie有什么区别？
### 12.session和cookie工作原理？
### 13.如果客户端禁止cookie能实现session还能用吗？

## 问题答案
### 1.HTTP资源请求方式有几种？
>HTTP/1.1协议中共定义了八种方法（有时也叫“动作”），来表明Request-URL指定的资源不同的操作方式                   
 HTTP1.0定义了三种请求方法： GET, POST 和 HEAD方法。                  
 HTTP1.1新增了五种请求方法：OPTIONS, PUT, DELETE, TRACE 和 CONNECT 方法                      
 在HTTP/1.1标准制定之后，又陆续扩展了一些方法。其中使用中较多的是 PATCH 方法                  
 (1).GET请求指定的页面信息，并返回响应主体，GET被认为是不安全的方法，因为GET方法会被网络蜘蛛等任意的访问。                    
 GET请求会显示请求指定的资源。一般来说GET方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。              
 (2).HEAD方法与GET方法一样，都是向服务器发出指定资源的请求。但是，服务器在响应HEAD请求时不会回传资源的内容部分(响应主体),只获取服务器的响应头信息。HEAD方法常被用于客户端查看服务器的性能。                   
 (3).POST会向指定资源提交数据，请求服务器进行处理，如：表单数据提交、文件上传等，请求数据会被包含在请求体中。POST方法是非幂等的方法，因为这个请求可能会创建新的资源或/和修改现有资源。                  
 (4).PUT请求会向指定资源位置上传其最新内容，PUT方法是幂等的方法。通过该方法客户端可以将指定资源的最新数据传送给服务器取代指定的资源的内容。                 
 (5).DELETE请求用于请求服务器删除所请求URI（统一资源标识符，Uniform Resource Identifier）所标识的资源。DELETE请求后指定资源会被删除，DELETE方法也是幂等的。                    
 (6).CONNECT方法是HTTP/1.1协议预留的，能够将连接改为管道方式的代理服务器。通常用于SSL加密服务器的链接与非加密的HTTP代理服务器的通信。                
 (7).OPTIONS请求与HEAD类似，一般也是用于客户端查看服务器的性能。 这个方法会请求服务器返回该资源所支持的所有HTTP请求方法，该方法会用'*'来代替资源名称，
>向服务器发送OPTIONS请求，可以测试服务器功能是否正常。JavaScript的XMLHttpRequest对象进行CORS跨域资源共享时，就是使用OPTIONS方法发送嗅探请求，以判断是否有对指定资源的访问权限。               
 (8).TRACE请求服务器回显其收到的请求信息，该方法主要用于HTTP请求的测试或诊断。              
 (9).PATCH请求与PUT请求类似，同样用于资源的更新。二者有以下两点不同：PATCH一般用于资源的部分更新，而PUT一般用于资源的整体更新。当资源不存在时，PATCH会创建一个新的资源，而PUT只会对已在资源进行更新。                   
### 2.http状态码
>1xx(信息提示，临时响应)                         
 100	继续	请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。                 
 101	切换协议	请求者已要求服务器切换协议，服务器已确认并准备切换。              
 102	继续执行	由WebDAV（RFC 2518）扩展的状态码，代表处理将被继续执行。                 
>                                            
>2xx(成功)                    
 200	成功	服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。                     
 201	已创建	请求成功并且服务器创建了新的资源。                   
 202	已接受	服务器已接受请求，但尚未处理。                     
 203	非授权信息	文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝，非权威性信息                
 204	无内容	没有新文档，浏览器应该继续显示原来的文档。               
 205	重置内容	没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容                  
 206	部分内容	服务器成功处理了部分 GET 请求。客户发送了一个带有Range头的GET请求（分块请求），服务器完成了它               
>                               
>3xx(重定向)                            
 300	多种选择	针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。               
 301	永久重定向	请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。             
 302	临时重定向	服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。                    
 304	未修改	客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。服务器告诉客户，原来缓冲的文档还可以继续使用。              
 305	使用代理	客户请求的文档应该通过Location头所指明的代理服务器提取             
>                           
>4xx(客户端错误)                             
 400	错误请求	服务器不理解请求的语法。                        
 401	未授权	请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。                     
 403	禁止	服务器拒绝请求。                    
 404	未找到	服务器找不到请求的网页。                    
 405	方法禁用	禁用请求中指定的方法。                         
 406	不接受	无法使用请求的内容特性响应请求的网页。                     
>                                           
>5xx(服务器错误)                                 
 500	服务器内部错误	服务器遇到错误，无法完成请求。                                 
 501	尚未实施	服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。                         
 502	错误网关	服务器作为网关或代理，从上游服务器收到无效响应。                            
 503	服务不可用	服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。                       
 504	网关超时	服务器作为网关或代理，但是没有及时从上游服务器收到请求。                            
 505	HTTP 版本不受支持	服务器不支持请求中所用的 HTTP 协议版本。                                 
### 3.get和post请求有哪些区别？
>GET和POST是HTTP协议中定义的两种发送请求的方法。HTTP是基于TCP/IP的关于数据如何在万维网中如何通信的协议。
>GET和POST本质上就是TCP链接，并无差别。但是由于HTTP的规定和浏览器/服务器的限制，导致他们在应用过程中体现出一些不同：              
 (1).GET是从指定的服务器中获取数据;POST是提交数据给指定的服务器处理                
 (2).GET请求的数据会附在URL之后，以?分割URL和传输数据，多个参数之间以&相连;
>POST方式将表单内各个字段和内容放置在HTML HEADER中一起传送到Action属性所指定的URL地址，用户是看不到这个过程的             
 (3).GET方式提交的数据最多只能是1024字节，理论上POST没有限制，可传较大量的数据             
 (4).服务端获取GET请求参数用Request.QueryString，获取POST请求参数用Request.Form               
 (5).GET请求会被浏览器主动cache，而POST不会，除非手动设置。              
 (6).对参数的数据类型，GET只接受ASCII字符，而POST没有限制。              
 (7).POST的安全性要比GET的安全性高。                
 (8).GET和POST一个重大区别：GET产生一个TCP数据包；POST产生两个TCP数据包。对于GET方式的请求，浏览器会把http header和data一并发送出去，
>服务器响应200(返回数据)；而对于POST，浏览器先发送http header，服务器响应100之后浏览器再发送data，服务器响应200(返回数据)。
>但是并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。                 
### 4.简述tcp和udp的区别？
>(1).TCP是面向连接的运输层协议;UDP是无连接的，即发送数据之前不需要建立连接             
 (2).TCP提供可靠交付的服务;UDP使用尽最大努力交付，即不保证可靠交付             
 (3).TCP是面向字节流;UDP是面向报文的                
 (4).TCP首部最低20个字节;UDP的首部开销小，只有8个字节              
 (5).每一条TCP连接只能是点到点的;UDP支持一对一，一对多，多对一和多对多的交互通信              
 (6).TCP的逻辑通信信道是全双工的可靠信道，UDP则是不可靠信道         
>(7).TCP对系统资源要求较多，UDP对系统资源要求较少                                             
### 5.tcp为什么要三次握手，两次不行吗？为什么？
>![tcp](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/tcp.png)              
>为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？                    
 因为服务端的LISTEN状态下的SOCKET当收到SYN报文的建连请求后，它可以把ACK和SYN（ACK起应答作用，而SYN起同步作用）放在一个报文里来发送。                        
 但关闭连接时，当收到客户端的FIN报文通知时，它仅仅表示客户端没有数据发送了；但未必服务端的数据都全部发送给客户端了，服务端可能还需要发送一些数据给客户端之后，
 再发送FIN报文给客户端来表示同意现在可以关闭连接了，所以关闭连接的ACK报文和FIN报文多数情况下都是分开发送的。                     
 为什么TIME_WAIT状态还需要等2MSL后才能返回到CLOSED状态？              
 因为虽然双方都同意关闭连接了，而且握手的4个报文也都发送完毕，按理可以直接回到CLOSED 状态(就好比从SYN_SENT 状态到ESTABLISH 状态那样)，但是必须假想网络是不可靠的，
 无法保证客户端最后发送的ACK报文一定会被对方收到，就是说对方处于LAST_ACK 状态下的SOCKET可能会因为超时未收到ACK报文，而重发FIN报文，所以这个TIME_WAIT状态的作用就是用来重发可能丢失的ACK报文。                   
 tcp 为什么要三次握手，两次不行吗？为什么？                        
 为了实现可靠数据传输， TCP 协议的通信双方， 都必须维护一个序列号， 以标识发送出去的数据包中， 哪些是已经被对方收到的。 三次握手的过程即是通信双方相互告知序列号起始值， 并确认对方已经收到了序列号起始值的必经步骤。
 如果只是两次握手， 至多只有连接发起方的起始序列号能被确认， 另一方选择的序列号则得不到确认。                                 
### 6.OSI的七层模型都有哪些？
>应用层：网络服务与最终用户的一个接口。                    
 表示层：数据的表示、安全、压缩。                       
 会话层：建立、管理、终止会话。                    
 传输层：定义传输数据的协议端口号，以及流控和差错校验。                
 网络层：进行逻辑地址寻址，实现不同网络之间的路径选择。                        
 数据链路层：建立逻辑连接、进行硬件地址寻址、差错校验等功能。                     
 物理层：建立、维护、断开物理连接。
### 7.forward和redirect的区别？
>Forward和Redirect代表了两种请求转发方式：直接转发和间接转发。                         
 直接转发方式（Forward）:客户端只发出一次请求，Servlet、HTML、JSP或其它信息资源，由第二个信息资源响应该请求，在请求对象request中，保存的对象对于每个信息资源是共享的。                      
 间接转发方式（Redirect）:客户端实际是两次HTTP请求，服务器端在响应第一次请求的时候，让浏览器再向另外一个URL发出请求，从而达到转发的目的。               
 直接转发就相当于：“A找B借钱，B说没有，B去找C借，借到借不到都会把消息传递给A”；                        
 间接转发就相当于："A找B借钱，B说没有，让A去找C借"。                  
### 8.如何实现跨域？
>跨域请求是指当前发起请求的域与该请求指向的资源所在的域不一样。域是指协议 + 域名 + 端口号。如果协议 + 域名 + 端口号均相同，那么就是同域。             
 如果域不一致，会存在安全问题，跨域请求会受到同源策略限制。同源策略是浏览器最核心最基础的安全策略。              
 跨域解决方法：                
 虽然在安全层面上同源限制是必要的，但有时同源策略会对合理用途造成影响，为了避免开发的应用受到限制，有多种方式可以绕开同源策略。                
 CORS(Cross-Origin Resource Sharing)跨域资源共享是一个新的 W3C 标准，它新增的一组HTTP首部字段，允许服务端其声明哪些源站有权限访问哪些资源。
>它允许浏览器向声明了CORS的跨域服务器，发出XMLHttpReuest请求                     
>                                   
>Access-Control-Allow-Origin: *                         
 Access-Control-Allow-Methods: POST, GET, OPTIONS                               
 Access-Control-Allow-Headers: X-PINGOTHER, Content-Type                        
 Access-Control-Max-Age: 86400                  
 跨域请求默认不会携带Cookie信息，如果需要携带，请配置下述参数：                     
 "Access-Control-Allow-Credentials": true                       
 // Ajax设置                      
 "withCredentials": true                            
### 9.什么是RESTful架构?
>RESTful架构是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便。                    
 REST是Representational State Transfer的缩写，"(资源)表现层状态转化"。                 
 REST的名称"表现层状态转化"中，省略了主语。"表现层"其实指的是"资源"（Resources）的"表现层"。               
 所谓"资源"，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。
>可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。                  
 表现层（Representation）                    
 "资源"是一种信息实体，它可以有多种外在表现形式。把"资源"具体呈现出来的形式，叫做它的"表现层"（Representation）。                              
 比如，文本可以用txt格式表现，也可以用HTML格式、XML格式、JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。                
 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的".html"后缀名是不必要的，因为这个后缀名表示格式，属于"表现层"范畴，
>而URI应该只代表"资源"的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对"表现层"的描述。                     
 状态转化（State Transfer）                   
 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。
 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，
>让服务器端发生"状态转化"（State Transfer）。而这种转化是建立在表现层之上的，所以就是"表现层状态转化"。               
 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。
>它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。                   
 综述:                        
 (1).每一个URI代表一种资源；                  
 (2).客户端和服务器之间，传递这种资源的某种表现层；                    
 (3).客户端通过四个HTTP动词，对服务器端资源进行操作，实现"表现层状态转化"。             
### 10.Http和https的区别
>(1).http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。                                    
 https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。
>此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份。                   
 (2).https协议需要到ca申请证书，一般免费证书很少，需要交费。                 
 (3).http是超文本传输协议，信息是明文传输，https 则是具有安全性的ssl加密传输协议                   
 (4).http和https使用的是完全不同的连接方式用的端口也不一样,前者是80,后者是443。                   
 (5).http的连接很简单,是无状态的                                  
 https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议 要比http协议安全             
### 11.session和cookie有什么区别？
> (1).存储位置不同            
  cookie的数据信息存放在客户端浏览器上         
  session的数据信息存放在服务器上           
  (2).存储容量不同            
  单个cookie保存的数据<=4KB，一个站点最多保存20个Cookie              
  对于session来说存储容量并没有上限，但出于对服务器端的性能考虑，session内不要存放过多的东西，并且服务器端会设置session删除机制             
  (3).存储方式不同            
  cookie中只能保管ASCII字符串，并需要通过编码方式存储为Unicode字符或者二进制数据          
  session中能够存储任何类型的数据，包括且不限于string，integer，list，map等            
  (4).隐私策略不同            
  cookie是不安全的，因为cookie对客户端是可见的，别有用心的人可以分析存放在本地的cookie并进行cookie欺骗            
  session存储在服务器上，对客户端是透明，不存在敏感信息泄漏的风险           
  (5).有效期上不同    
  可以通过设置cookie的属性，达到使cookie长期有效的效果          
  session依赖于名为JSESSIONID的cookie，而JSESSIONID的cookie过期时间默认为-1，只需关闭窗口该session就会失效，因而session不能达到长期有效的效果             
  (6).服务器压力不同           
  cookie保管在客户端，不占用服务器资源。对于并发用户十分多的网站，cookie是很好的选择               
  session是保管在服务器端的，每个用户都会产生一个session。假如并发访问的用户十分多，会产生十分多的session，耗费大量的内存            
  (7).浏览器支持不同                   
  假如客户端浏览器不支持cookie：                
  cookie是需要客户端浏览器支持的，假如客户端禁用了cookie，或者不支持cookie，则会话跟踪会失效。关于WAP上的应用，常规的cookie就派不上用场了             
  运用session需要使用URL地址重写的方式。一切用到session程序的URL都要进行URL地址重写，否则session会话跟踪还会失效                                    
  假如客户端支持cookie：                
  cookie既能够设为本浏览器窗口以及子窗口内有效，也能够设为一切窗口内有效            
  session只能在本窗口以及子窗口内有效             
  (8).跨域支持上不同               
  cookie支持跨域名访问             
  session不支持跨域名访问                   
### 12.session和cookie工作原理？
> cookie工作原理                        
> 因为HTTP协议是无状态的，即服务器不知道用户上一次做了什么，这严重阻碍了交互式Web应用程序的实现。服务器可以设置或读取Cookies中包含信息，借此维护用户跟服务器会话中的状态。                   
  Cookie是指某些网站为了辨别用户身份、进行session跟踪而储存在用户本地终端上的数据（通常经过加密）。               
  Cookie是由服务端生成的，发送给客户端（通常是浏览器）的。Cookie总是保存在客户端中，按在客户端中的存储位置，可分为内存Cookie和硬盘Cookie：          
  内存Cookie由浏览器维护，保存在内存中，浏览器关闭后就消失了，其存在时间是短暂的。               
  硬盘Cookie保存在硬盘里，有一个过期时间，除非用户手工清理或到了过期时间，硬盘Cookie不会被删除，其存在时间是长期的。所以，按存在时间，可分为非持久Cookie和持久Cookie。            
                                                                      
> 工作原理                                    
  当用户第一次浏览某个使用Cookie的网站时，该网站的服务器就进行如下工作：                
  (1).服务器为该用户生成一个唯一的识别码（Cookie id），创建一个Cookie对象。默认情况下是一个会话级别的cookie，存储在浏览器的内存中，
> 用户退出浏览器之后被删除。如果网站希望浏览器将该Cookie存储在磁盘上，则需要设置最大时效（maxAge），并给出一个以秒为单位的时间（将最大时效设为0则是命令浏览器删除该Cookie）                
  (2).将Cookie放入到HTTP响应报头，将Cookie插入到一个Set-Cookie HTTP请求报头中,发送该HTTP响应报文给用户                
  (3).浏览器收到该响应报文之后，根据报文头里的Set-Cookied特殊的指示，生成相应的Cookie，保存在客户端。该Cookie里面记录着用户当前的信息。              
  (4).当用户再次访问该网站时，浏览器首先检查所有存储的Cookies，如果存在该网站的Cookie（即该Cookie所声明的作用范围大于等于将要请求的资源），则把该cookie附在请求资源的HTTP请求头上发送给服务器                
  (5).服务器接收到用户的HTTP请求报文之后，从报文头获取到该用户的Cookie，从里面找到所需要的东西         
>                   
> 作用                    
  Cookie的根本作用就是在客户端存储用户访问网站的一些信息。典型的应用有：            
  (1).记住密码，下次自动登录           
  (2).购物车功能         
  (3).记录用户浏览数据，进行商品（广告）推荐。          
>                       
> 缺陷            
  (1).Cookie会被附加在每个HTTP请求中，所以无形中增加了流量。          
  (2).由于在HTTP请求中的Cookie是明文传递的，所以安全性成问题。（除非用HTTPS）           
  (3).Cookie的大小限制在4KB左右。对于复杂的存储需求来说是不够用的。               
  session代表服务器与浏览器的一次会话过程，这个过程是连续的，也可以时断时续的。session是一种服务器端的机制，session对象用来存储特定用户会话所需的信息。             
  session由服务端生成，保存在服务器的内存、缓存、硬盘或数据库中。   
>                                           
> session工作原理                   
> 当用户访问到一个服务器，如果服务器启用session，服务器就要为该用户创建一个session，在创建这个session之前，服务器首先检查这个用户发来的请求里是否包含了一个SESSION ID，
> 如果包含了一个SESSION ID则说明之前该用户已经登陆过并为此用户创建过SESSION，那服务器就按照这个SESSION ID把这个SESSION在服务器的内存中查找出来，如果查找不到，就有可能为他新创建一个，
> 如果客户端请求里不包含有SESSION ID，则为该客户端创建一个SESSION并生成一个与此SESSION相关的SESSION ID。这个SESSION ID是唯一的、不重复的、不容易找到规律的字符串，
> 这个SESSION ID将被在本次响应中返回到客户端保存，而保存这个SESSION ID的是一个名为JSESSIONID的cookie，这样在用户和服务端交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。                        
### 13.如果客户端禁止cookie能实现session还能用吗？
> 如果客户端禁止cookie,session是能用的。                
  在禁用cookie的情况下,通过url重写，把SessionId直接附加在URL路径的后面:            
  [1].作为URL路径的附加信息;             
  [2].作为查询字符串附加在URL后面;              
  [3].表单隐藏字段,就是服务器会自动修改表单，添加一个隐藏字段，以便在表单提交时能够把SessionId传递回客户端。          
  实现浏览器与服务器交互。                   