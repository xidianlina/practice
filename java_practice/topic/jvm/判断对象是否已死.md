### 7.判断对象是否已死
> 存活:正在被使用的对象。                          
  已死:不可能再通过任何途径使用的对象。                   
>                                                                       
> 引用计数算法:给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1;当引用失效时，计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。                    
  优点:实现简单，判断效率高。                    
  缺点:假设两个对象均无用，此时若相互引用对方，那么会导致引用计数不为0。这样一来这两个对象永远不会被回收。                 
  至少主流的Java虚拟机里面没有选用引用计数法来管理内存，最主要原因是它很难解决对象之间相互引用的问题。              
>                         
> 可达性分析算法:通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为"引用链"，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。                      
  优点:解决引用计数法无法解决的对象相互调用问题                       
  缺点:寻找GC Roots消耗很多时间                       
>                                 
> 在Java语言中，可作为GC Roots的对象(即:GC Root Set)包括下面几种：                     
  虚拟机栈(栈帧中的本地变量表)中引用的对象。                
  方法区中类静态属性引用的对象。                   
  方法区汇总常量引用的对象。                 
  本地方法栈中JNI(即一般说的Native方法)引用的对象。 
>                   
> 生存还是死亡：                   
> 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候他们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:                    
> 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。                    
> 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。                 
> 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中并在稍后由一个由虚拟机自动创建的、低优先级的Finalizer线程去执行它。                  
> 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，                                        
> 将很可能导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对于F-Queue中的对象进行第二次小规模的标记，                         
> 如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，如:把自己(this关键字)赋值给某个类变量或者对象的成员变量，               
> 那在第二次标记时它将被移除出“即将回收”集合;如果对象这时候还没有逃脱，那基本上它就真的被回收了。                 
> ![object_finalize](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/object_finalize.png)                                                                          
