### 17.类加载机制        
> JVM类加载机制分为五个部分:加载，验证，准备，解析，初始化            
> ![classloader](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/classloader.png)                     
> 其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。           
>                                       
> (1).加载:根据查找路径找到相应的class文件然后导入                                   
  通过一个类的全限定名来获取定义此类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。                   
  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。                   
  在内存中生成一个代表这个类的java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。              
  数组类的特殊性：数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：                              
  如果数组的元素类型是引用类型，那就递归采用类加载加载。               
  如果数组的元素类型不是引用类型，Java虚拟机会把数组标记为引导类加载器关联。               
  数组类的可见性与它的元素类型的可见性一致，如果元素类型不是引用类型，那数组类的可见性将默认为public。                 
  内存中实例的java.lang.Class对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。                  
  加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。            
>                                          
> (2).验证:检查加载的 class 文件的正确性                                     
> 是连接的第一步，确保Class文件的字节流中包含的信息符合当前虚拟机要求。             
> [1].文件格式验证                
> 是否以魔数 0xCAFEBABE 开头                              
  主、次版本号是否在当前虚拟机处理范围之内              
  常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）                   
  指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量                   
  CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据                                 
  Class文件中各个部分集文件本身是否有被删除的附加的其他信息           
> [2].元数据验证         
> 这个类是否有父类（除 java.lang.Object 之外）               
  这个类的父类是否继承了不允许被继承的类（final 修饰的类）               
  如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法             
  类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载                        
> [3].字节码验证             
>  保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作（不会出现按照 long 类型读一个 int 型数据）                  
   保证跳转指令不会跳转到方法体以外的字节码指令上                  
   保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）                                        
> [4].符号引用验证            
> 符号引用中通过字符描述的全限定名是否能找到对应的类                    
  在指定类中是否存在方法的字段描述符以及简单名称所描述的方法和字段             
  符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问          
>               
>(3).准备:给类中的静态变量分配内存空间                             
> 准备阶段正式为类分配内存并设置类变量初始值，内存在方法区中分配(含static修饰的变量不含实例变量)。                              
>               
>(4).解析:虚拟机将常量池中的符号引用替换成直接引用的过程                            
> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。                      
> 符号引用:符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。                
  直接引用:直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和jvm的内存布局实现有关。                      
  解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的7中常量类型。                
> (5).初始化:对静态变量和静态代码块执行初始化工作                       
> 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。            
