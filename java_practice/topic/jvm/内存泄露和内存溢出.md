### 22.java中的内存泄露和内存溢出？
>Java内存泄露与溢出的区别:                        
 Java内存泄漏是没有及时清理内存垃圾，导致系统无法再提供内存资源（内存资源耗尽）                      
 Java内存溢出是要求分配的内存超出了系统能给的，系统不能满足需求，于是产生溢出。                                  
 一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。                                 
 (1).静态集合类:如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，
>从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。                       
 (2).物理链接:如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。                   
>只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。                                  
 (3).改变哈希值:当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进
>HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对
>象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露                 
 (4).内部类持有外部类:如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，
>但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。                    
 (5).变量不合理的作用域:一个变量定义的作用范围大于其使用范围，很有可能会造成内存泄漏。
>另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。                      
 (6).单例模式:因为单例对象的初始化将在JVM的整个生命周期内存在，如果它持有一个外部对象的(生命周期比较短)引用，那么这个外部对象就不能被回收，
>从而导致内存泄露。如果这个外部对象还持有其他对象的引用，那么内存泄露更严重。              