java虚拟机JVM
======
## 问题列表
### 1.Java虚拟机运行时数据区域
### 2.对象是如何创建、如何布局以及如何访问的？
### 3.判断对象是否已死
### 4.对象的引用
### 5.回收方法区
### 6.垃圾回收算法
### 7.垃圾回收器
### 8.内存分配与回收策略
### 9.Java 内存模型
### 10.先行发生原则
### 11.类加载机制
### 12.类加载器
### 13.双亲委派模型
### 14.Student s=new Student();在内存中做了哪些事情?
### 15.JVM的主要组成部分？及其作用？
### 16.jvm中堆栈的区别？
### 17.简述分代垃圾回收器是怎么工作的？
### 18.jvm调优的工具？
### 19.常用的jvm调优的参数都有哪些？
### 20.java中的内存泄露和内存溢出？
## 问题答案
### 1.Java虚拟机运行时数据区域
> ![java_run_data_area](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/java_run_data_area.png)                                               
> (1).方法区:属于共享内存区域，存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。  
>                                      
> (2).堆:对于绝大多数应用来说，这块区域是JVM所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。                                  
  OutOfMemoryError:如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。           
>                             
> (3).Java虚拟机栈:线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。                  
  局部变量表:存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)                  
  StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。                       
  OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。     
>                               
> (4).本地方法栈:区别于Java虚拟机栈的是，Java虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。也会有StackOverflowError和OutOfMemoryError异常。
>                                       
> (5).程序计数器:内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。                                    
  如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器的值则为(Undefined)。
> 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。                                          
> ![java_run_data_area2](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/java_run_data_area2.png)                 
>                                                                        
> (6).运行时常量池:属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。                 
>                                   
> (7).直接内存:非虚拟机运行时数据区的部分                        
  在JDK1.4中新加入NIO(New Input/Output)类，引入了一种基于通道(Channel)和缓存(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。可以避免在Java堆和Native 堆中来回的数据耗时操作。
  OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。                                                                                    
### 2.对象是如何创建、如何布局以及如何访问的？
> (1).对象的创建             
> 在语言层面上，对象的创建常见方式是new关键字进行创建(还可以通过反射、反序列化、克隆创建)，在jvm内部，jvm碰到new指令以后在内部是如何操作的？                  
  jvm碰到new指令执行流程:                   
  [1].检查指令参数能否在方法区常量池中定位到一个符号引用。如果无法定位到一个符号引用，说明这个类没有定义，将抛出ClassNotFoundException                   
  [2].检查这个符号引用所对应的类有没有被加载，解析和初始化。如果没有，需要执行加载过程。                 
  [3].在类已被加载，解析、初始化以后，需要在堆中为新生对象分配内存。对象在类加载以后，由类生产的对象大小即可确定。                    
  在堆中分配对象空间的方法有指针碰撞法和空闲列表法。对象采用何种分配算法，取决于jvm采用何种垃圾回收算法，标记清除算法适合采用空闲列表，而标记整理，复制算法适合于指针碰撞法。                   
  指针碰撞法：java堆属于规整状态，已用堆内存在一侧，空闲堆内存在另一侧，中间通过指针分割并划分内存，当有新生对象到来时，通过移动指针给新生对象划分特定大小的内存。                    
  这种方法要求java堆必须处于规整状态。                  
  空闲列表法：堆内存可以不规整，此时需要通过一个空闲列表记录在堆内存中存在的空间空间。当有新生代对象到来时，通过查看空闲列表，找到适合对象大小的内存空间，将空间分配给该对象，并修改空闲列表。                
  这种方法需要划出额外的空间用于维护空闲列表。                    
  [4].为对象中的成员变量赋上默认初始值                  
  [5].设置对象头信息，对象是属于哪个类的实例，对象的哈希码，对象的GC分代年龄等             
  [6].调用对象的构造函数进行初始化。 
>                                     
> (2).对象在内存中的布局             
  在hotspot虚拟机中，对象在内存中的布局分为三个部分:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。           
  对象头               
  存储对象在运行中需要用到的数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、线程偏向ID、偏向时间戳等；                
  类型指针：对象指向其类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例；             
  如果对象是数组，对象头中还有一块区域用于保存数组大小；               
  实例数据              
  存放的是对象各种类型字段的值，包括父类成员变量，子类成员变量            
  对齐填充          
  hotspot jvm要求对象起始地址必须是8字节的整数倍，所以要保证一个对象所占的内存是8的整数倍，由于对象头正好是8的整数倍，所以通过填充实例数据使其成为8字节的整数倍，使对象对齐。             
>                            
> (3).对象的访问定位                   
  使用对象时，通过栈上的reference数据来操作堆上的具体对象。                 
  在jvm中有2种对象定位方式，一种是句柄访问，一种是直接地址访问。             
  句柄访问                  
  java堆中划分出一块内存作为句柄池，虚拟机栈中存储的是对象的句柄地址，句柄中包含了对象的实例地址和元数据地址。访问对象时，先根据对象引用找到句柄池地址，再根据句柄池中的对象数据地址找到对象。              
> ![object_ref1](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/object_ref1.png)                                                           
> 直接地址访问                
  虚拟机栈中的引用存储的是对象在堆内存中的地址，通过该地址直接定位到对象，不需要经过中间媒介，更加快速，但是在对象的内存结构中需要存储对象的类型指针，用于定位方法区的对象类型。               
> ![object_ref2](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/object_ref2.png)                                                     
  比较:使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。             
> 直接指针访问的最大好处是速度快，因为它只需要一次寻址操作,节省了一次指针定位的时间开销。但它在对象内存结构中需要额外存储类型指针。
  如果是对象频繁GC那么句柄方法好，如果是对象频繁访问则直接指针访问好。hotspot采用的对象访问方式就是直接地址访问。                                     
### 3.判断对象是否已死
> 存活:正在被使用的对象。                          
  已死:不可能再通过任何途径使用的对象。                   
>                                                                       
> 引用计数算法:给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1;当引用失效时，计数器值就减1;任何时刻计数器为0的对象就是不可能再被使用的。                    
  优点:实现简单，判断效率高。                    
  缺点:假设两个对象均无用，此时若相互引用对方，那么会导致引用计数不为0。这样一来这两个对象永远不会被回收。                 
  至少主流的Java虚拟机里面没有选用引用计数法来管理内存，最主要原因是它很难解决对象之间相互引用的问题。              
>                         
> 可达性分析算法:通过一系列称为"GC Roots"的对象作为起始点，从这些节点开始向下搜索，搜索走过的路径称为"引用链"，当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。                      
  优点:解决引用计数法无法解决的对象相互调用问题                       
  缺点:寻找GC Roots消耗很多时间                       
>                                 
> 在Java语言中，可作为GC Roots的对象(即:GC Root Set)包括下面几种：                     
  虚拟机栈(栈帧中的本地变量表)中引用的对象。                
  方法区中类静态属性引用的对象。                   
  方法区汇总常量引用的对象。                 
  本地方法栈中JNI(即一般说的Native方法)引用的对象。 
>                   
> 生存还是死亡：                   
> 即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候他们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程:                    
> 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalizw()方法。                    
> 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。                 
> 如果这个对象被判定为有必要执行finalize()方法，那么这个对象将会放置在一个叫做F-Queue的队列中并在稍后由一个由虚拟机自动创建的、低优先级的Finalizer线程去执行它。                  
> 这里所谓的“执行”是指虚拟机会触发这个方法，但并不承诺会等待它运行结束，这样做的原因是，如果一个对象在finalize()方法中执行缓慢，或者发生了死循环(更极端的情况)，                                        
> 将很可能导致F-Queue队列中其他对象永久处于等待，甚至导致整个内存回收系统崩溃。finalize()方法是对象逃脱死亡命运的最后一次机会，稍后GC将对于F-Queue中的对象进行第二次小规模的标记，                         
> 如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何一个对象建立关联即可，如:把自己(this关键字)赋值给某个类变量或者对象的成员变量，               
> 那在第二次标记时它将被移除出“即将回收”集合;如果对象这时候还没有逃脱，那基本上它就真的被回收了。                 
> ![object_finalize](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/object_finalize.png)                                                                          
             
### 4.对象的引用
> 在JDK1.2以前，Java中的引用的定义很传统:如果reference类型的数据中存储的数值代表的是另外一块内存的起始地址，就称这块内存代表着一个引用。                              
> 在JDK1.2(含)之后，Java对引用的概念进行了补充，将引用分为强引用(String Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(Phantom Reference)4中，这4种引用的引用强度依次逐渐减弱。                           
> 强引用:指在程序代码之中普遍存在的，类似“Object obj = new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。                 
  软引用:SoftReference类实现软引用。描述一些还有用但并非必需的对象。对于软引用关联着的对象，在系统中将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。                
  除了强引用外，其它三种引用方式中，软引用使用得最多。在开发中，可以利用软引用实现高速缓存。                     
  弱引用:WeakReference类实现弱引用。弱引用也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。也就说：当垃圾收集器工作时，无论当前内存是否足够，都会回收掉被弱引用关联的对象。                     
  虚引用(幽灵引用、幻影引用):PhantomReference类实现虚引用。最弱的一种引用。一个对象是否有虚引用的存在，完全不会对其生存时间造成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。                    
### 5.回收方法区
> 在堆中，尤其是在新生代中，一次垃圾回收一般可以回收70% ~ 95%的空间，而永久代的垃圾收集效率远低于此。                    
  永久代垃圾回收主要两部分内容：废弃的常量和无用的类。                
  判断废弃常量：一般是判断没有该常量的引用。             
  判断无用的类：要以下三个条件都满足                     
  该类所有的实例都已经回收，也就是Java堆中不存在该类的任何实例                  
  加载该类的ClassLoader已经被回收                 
  该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法                
  在大量使用反射、动态代理、CGLib等ByteCode框架的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。                
### 6.垃圾回收算法
> (1).标记-清除算法
> 标记-清除算法分为两个阶段：标记阶段和清除阶段。标记阶段的任务是标记出所有需要被回收的对象，清除阶段就是回收被标记的对象所占用的空间。               
> 缺点:效率不高;容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作。               
>                                                   
> (2).复制算法
> 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用的内存空间一次清理掉，这样一来就不容易出现内存碎片的问题。                      
> 这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。很显然，Copying算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么Copying算法的效率将会大大降低。           
> 因为大多数新生代对象都不会熬过第一次GC。所以没必要1:1划分空间。可以分一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中一块Survivor。
> 当回收时，将Eden和Survivor中还存活的对象一次性复制到另一块Survivor上，最后清理Eden和Survivor空间。大小比例一般是8:1:1，每次浪费10%的Survivor空间。但是这里有一个问题就是如果存活的大于10%怎么办？这里采用一种分配担保策略多出来的对象直接进入老年代。
>                                       
> (3).标记-整理算法（压缩法）
> 不同于针对新生代的复制算法，针对老年代的特点，创建该算法。主要是把存活对象移到内存的一端。                 
>                           
> (4).分代收集算法                
> 分代收集算法是目前大部分JVM的垃圾收集器采用的算法。它的核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。
> 一般情况下将堆区划分为老年代（Tenured Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，
> 而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。
  目前大部分垃圾收集器对于新生代都采取复制算法，因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少。
> 一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，
> 当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间。
  而由于老年代的特点是每次回收都只回收少量对象，一般使用的是标记-整理算法（压缩法）。
### 7.垃圾回收器
> 收集算法是内存回收的理论，而垃圾回收器是内存回收的实践。                                            
> ![gc](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/gc.png)                              
> 说明：如果两个收集器之间存在连线说明他们之间可以搭配使用。             
> (1).Serial 收集器                
> 一个单线程收集器。意味着它只会使用一个CPU或一条收集线程去完成收集工作，并且在进行垃圾回收时必须暂停其它所有的工作线程直到收集结束。                 
>                                                                                                                         
> (2).ParNew 收集器            
> Serial 收集器的多线程版本。多条垃圾收集线程并行工作，此时用户线程处于等待状态。                 
>                                                                                                
> (3).Parallel Scavenge 收集器                 
> 是一个新生代的多线程收集器（并行收集器），它在回收期间不需要暂停其他用户线程，其采用的是Copying算法，该收集器与前两个收集器有所不同，它主要是为了达到一个可控的吞吐量(Throughput = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间))。           
>                                                                                           
> (4).CMS 收集器                              
>  CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。基于标记 — 清除算法实现。
> 运作步骤:
> [1].初始标记(CMS initial mark)：标记GC Roots能直接关联到的对象                              
  [2].并发标记(CMS concurrent mark)：进行GC Roots Tracing                              
  [3].重新标记(CMS remark)：修正并发标记期间的变动部分。                   
> 修正并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录。停顿时间：初始标记<重新标记<<并发标记                                           
  [4].并发清除(CMS concurrent sweep)                        
> 缺点:对CPU资源敏感;              
> 无法收集浮动垃圾(并发清理阶段用户程序运行产生的垃圾过了标记阶段所以无法在本次收集中清理掉，称为浮动垃圾);                 
> 标记 — 清除算法带来的空间碎片。                    
>                                                                                                   
> (5).Serial Old 收集器            
> 收集器的老年代版本，单线程，使用 标记 — 整理 算法。           
>                                                                                             
> (6).Parallel Old 收集器                       
> Parallel Old是Parallel Scavenge收集器的老年代版本。多线程，使用 标记 — 整理 算法。                
>           
> (7).G1 收集器            
> 面向服务端的垃圾回收器。它能充分利用多CPU、多核环境。基于 标记 — 整理 算法。                                                    
  优点：并行与并发、分代收集、空间整合、可预测停顿。                          
> 运作步骤:                                      
> [1].初始标记(Initial Marking)
  [2].并发标记(Concurrent Marking)
  [3].最终标记(Final Marking)
  [4].筛选回收(Live Data Counting and Evacuation)               
> G1将整个Java堆（包括新生代、老年代）划分为多个大小固定的独立区域（Region），并且跟踪这些区域里面的垃圾堆积程度，在后台维护一个优先列表，
> 每次根据允许的收集时间，优先回收垃圾最多的区域（这就是Garbage First名称的由来）。区域划分、有优先级的区域回收，保证了G1收集器在有限的时间内可以获得最高的收集效率。             
### 8.内存分配与回收策略
> 对象优先在Eden分配:                  
  在大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。                   
> Minor GC和Full GC的区别                   
  新生代Minor GC:指发生在新生代的垃圾收集动作，因为Java对象大多数都具有朝生夕灭的特性，多以Minor GC非常频繁，一般回收速度也比较快。               
  老年代GC（Major GC/Full GC）:指发生在老年代的GC,出现了Major GC,经常都伴随着至少一次的Minor GC(但并非绝对的，在ParallelScavenge收集器的收集策略里就有直接进行Major GC的策略选择过程)。MajorGC的速度一般会比Minor GC慢10倍以上。                  
> 在运行通过-Xms20M、-Xmx20M和-Xmn10M这三个参数限制Java堆大小为20MB,切不可扩展，其中10MB分配给新生代剩下的10MB分配给老年代。-XX:SurvivorRatio=8决定了新生代中Eden区与一个Survivor区的空间比例是8比1，新生代总可用空间为9216KB（Eden区+1个Survivor区的总容量）。                           
>               
> 大对象直接进入老年代                
> 所谓大对象就是需要大量连续空间的Java对象，最典型的大对象就是那种很长的字符串及数组。虚拟机提供了一个-XX:PretenureSizeThreshold参数，
> 令大于这些设置值的对象直接在老年代中分配。这样做的目的是在避免Eden区及两个Survivor区之间发生大量的内存拷贝（新生代采用复制算法手机内存）。               
>                       
> 长期存活的对象将进入老年代             
> 虚拟机给每个对象定义了一个对象年龄计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能够被Survivor容纳的话，将被移动到Survivor空间中，
> 并将对象年龄设置为1.对象在Survivor区每熬过一次Minor GC,年龄就增加一岁，当它的年龄增加到一定程度（默认15岁）时，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold来设置。                     
>               
> 动态对象年龄判定                  
> 为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，
> 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。                 
>                           
> 空间分配担保                                    
> 在发生Minor GC时，虚拟机就会检测之前每次晋升到老年代的平均大小是否大于老年代的剩余空间，如果大于，则改为直接进行一次Full GC.如果小于，
> 则查看HandlePromotionFailure设置是否允许担保失败；如果允许，那只会进行Minor GC:如果不允许，则也要改为进行一次Full GC。                    
  新生代使用复制收集算法，但为了内存利用率，只使用了其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况下，
> 就需要老年代进行分配担保，让Survivor无法容纳的对象直接进入老年代。但是前提老年代本身还有足够空间容纳这些对象。但是实际完成内存回收前是
> 无法知道多少对象存活，所以只好取之前每一次回收晋升到老年代对象容量的平均值作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多的空间。
  取平均值进行比较其实仍然是一种动态概率手段，也就是说如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（HandlePronotion Failuer）。
> 如果出现担保失败，那就只好在失败后重新发起一次Full GC。                                                      
### 9.Java内存模型
> java内存模型(JMM)屏蔽掉各种硬件和操作系统的内存访问差异，以实现让java程序在各种平台下都能达到一致的并发效果。                 
> Java内存模型规定所有的变量都存储在主内存中，包括实例变量，静态变量，但是不包括局部变量和方法参数。每个线程都有自己的工作内存，
> 线程的工作内存保存了该线程用到的变量和主内存的副本拷贝，线程对变量的操作都在工作内存中进行。线程不能直接读写主内存中的变量。                    
> 不同的线程之间也无法访问对方工作内存中的变量。线程之间变量值的传递均需要通过主内存来完成。         
> 每个线程的工作内存都是独立的，线程操作数据只能在工作内存中进行，然后刷回到主存。这是 Java 内存模型定义的线程基本工作方式。                               
> ![jmm](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/jmm.png)                                           
>                 
> JMM定义了什么?         
> JMM定义了原子性，可见性，有序性。                
> 原子性指的是一个操作是不可分割，不可中断的，一个线程在执行时不会被其他线程干扰。              
```java
package com.java.topic.jvm;

public class JMM {
    public static void main(String[] args) {
        int i = 2;  // 基本类型赋值操作，能保证原子性。
        int j = i;  // 先读取i的值，再赋值到j，两步操作，不能保证原子性。
        ++i;        // 先读取i的值，再+1，最后赋值到i，三步操作，不能保证原子性。
        i = i + 1;  // 先读取i的值，再+1，最后赋值到i，三步操作，不能保证原子性。
    }
}
```
> JMM只能保证基本的原子性，如果要保证一个代码块的原子性，提供了monitorenter 和 moniterexit 两个字节码指令，
> 也就是 synchronized 关键字。因此在 synchronized 块之间的操作都是原子性的。                   
> 可见性               
  可见性指当一个线程修改共享变量的值，其他线程能够立即知道被修改了。Java是利用volatile关键字来提供可见性的。 
> 当变量被volatile修饰时，这个变量被修改后会立刻刷新到主内存，当其它线程需要读取该变量时，会去主内存中读取新值。而普通变量则不能保证这一点。             
> 除了volatile关键字之外，final和synchronized也能实现可见性。                
> synchronized的原理是，在执行完进入unlock之前，必须将共享变量同步到主内存中。                                 
> final修饰的字段，一旦初始化完成，如果没有对象逸出（指对象未初始化完成就可以被别的线程使用），那么对于其他线程都是可见的。               
> 有序性                   
  在Java中，可以使用synchronized或者volatile保证多线程之间操作的有序性。实现原理有些区别：              
> volatile关键字是使用内存屏障达到禁止指令重排序，以保证有序性。                          
> synchronized的原理是，一个线程lock之后，必须unlock后，其他线程才可以重新lock，使得被synchronized包住的代码块在多线程之间是串行执行的。            
>                       
> 八种内存交互操作              
> lock(锁定)，作用于主内存中的变量，把变量标识为线程独占的状态。                
  read(读取)，作用于主内存的变量，把变量的值从主内存传输到线程的工作内存中，以便下一步的load操作使用。               
  load(加载)，作用于工作内存的变量，把read操作主存的变量放入到工作内存的变量副本中。                
  use(使用)，作用于工作内存的变量，把工作内存中的变量传输到执行引擎，每当虚拟机遇到一个需要使用到变量的值的字节码指令时将会执行这个操作。                    
  assign(赋值)，作用于工作内存的变量，它把一个从执行引擎中接受到的值赋值给工作内存的变量副本中，每当虚拟机遇到一个给变量赋值的字节码指令时将会执行这个操作。             
  store(存储)，作用于工作内存的变量，它把一个从工作内存中一个变量的值传送到主内存中，以便后续的write使用。                
  write(写入)：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。                     
  unlock(解锁)：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。                  
> ![jmm2](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/jmm2.png)                                                              
> JMM对8种内存交互操作制定的规则：                        
> 不允许read、load、store、write操作之一单独出现，也就是read操作后必须load，store操作后必须write。            
  不允许线程丢弃它最近的assign操作，即工作内存中的变量数据改变了之后，必须告知主存。              
  不允许线程将没有assign的数据从工作内存同步到主内存。             
  一个新的变量必须在主内存中诞生，不允许工作内存直接使用一个未被初始化的变量。就是对变量实施use、store操作之前，必须经过load和assign操作。                 
  一个变量同一时间只能有一个线程对其进行lock操作。多次lock之后，必须执行相同次数unlock才可以解锁。               
  如果对一个变量进行lock操作，会清空所有工作内存中此变量的值。在执行引擎使用这个变量前，必须重新load或assign操作初始化变量的值。                
  如果一个变量没有被lock，就不能对其进行unlock操作。也不能unlock一个被其他线程锁住的变量。              
  一个线程对一个变量进行unlock操作之前，必须先把此变量同步回主内存。   
>           
> Java要求对于主内存和工作内存之间的八个操作都是原子性的，但是对于64位的数据类型，有一条宽松的规定：
> 允许虚拟机将没有被volatile修饰的64位数据的读写操作划分为两次32位的操作来进行，即允许虚拟机实现选择可以不保证64位数据类型的load、store、read和write这4个操作的原子性。这就是long和double的非原子性协定。                                                    
>               
> 参考 https://segmentfault.com/a/1190000024555686
### 10.先行发生原则   
> 先行发生原则也就是happens-before原则。这个原则是判断数据是否存在竞争、线程是否安全的主要依据。先行发生是Java内存模型中定义的两项操作之间的偏序关系。                          
> ![happens-before](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/happens-before.png)                                                                                 
### 11.类加载机制        
> JVM类加载机制分为五个部分:加载，验证，准备，解析，初始化            
> ![classloader](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/classloader.png)                     
> 其中加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的。解析阶段可以在初始化之后再开始(运行时绑定或动态绑定或晚期绑定)。           
>                                       
> (1).加载:根据查找路径找到相应的class文件然后导入                                   
  通过一个类的全限定名来获取定义此类的二进制流(ZIP 包、网络、运算生成、JSP 生成、数据库读取)。                   
  将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。                   
  在内存中生成一个代表这个类的java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。              
  数组类的特殊性：数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型最终是要靠类加载器去创建的，数组创建过程如下：                              
  如果数组的元素类型是引用类型，那就递归采用类加载加载。               
  如果数组的元素类型不是引用类型，Java虚拟机会把数组标记为引导类加载器关联。               
  数组类的可见性与它的元素类型的可见性一致，如果元素类型不是引用类型，那数组类的可见性将默认为public。                 
  内存中实例的java.lang.Class对象存在方法区中。作为程序访问方法区中这些类型数据的外部接口。                  
  加载阶段与连接阶段的部分内容是交叉进行的，但是开始时间保持先后顺序。            
>                                          
> (2).验证:检查加载的 class 文件的正确性                                     
> 是连接的第一步，确保Class文件的字节流中包含的信息符合当前虚拟机要求。             
> [1].文件格式验证                
> 是否以魔数 0xCAFEBABE 开头                              
  主、次版本号是否在当前虚拟机处理范围之内              
  常量池的常量是否有不被支持常量的类型（检查常量 tag 标志）                   
  指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量                   
  CONSTANT_Utf8_info 型的常量中是否有不符合 UTF8 编码的数据                                 
  Class文件中各个部分集文件本身是否有被删除的附加的其他信息           
> [2].元数据验证         
> 这个类是否有父类（除 java.lang.Object 之外）               
  这个类的父类是否继承了不允许被继承的类（final 修饰的类）               
  如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法             
  类中的字段、方法是否与父类产生矛盾（覆盖父类 final 字段、出现不符合规范的重载                        
> [3].字节码验证             
>  保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作（不会出现按照 long 类型读一个 int 型数据）                  
   保证跳转指令不会跳转到方法体以外的字节码指令上                  
   保证方法体中的类型转换是有效的（子类对象赋值给父类数据类型是安全的，反过来不合法的）                                        
> [4].符号引用验证            
> 符号引用中通过字符创描述的全限定名是否能找到对应的类                    
  在指定类中是否存在符方法的字段描述符以及简单名称所描述的方法和字段             
  符号引用中的类、字段、方法的访问性（private、protected、public、default）是否可被当前类访问          
> (3).准备:给类中的静态变量分配内存空间                             
> 准备阶段正式为类分配内存并设置类变量初始值，内存在方法区中分配(含static修饰的变量不含实例变量)。                              
> (4).解析:虚拟机将常量池中的符号引用替换成直接引用的过程                            
> 解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。                      
> 符号引用:符号引用以一组符号来描述所引用的目标，符号可以使任何形式的字面量。                
  直接引用:直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用和jvm的内存布局实现有关。                      
  解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行，分别对应于常量池的7中常量类型。                
> (5).初始化:对静态变量和静态代码块执行初始化工作                       
> 初始化阶段是类加载最后一个阶段，前面的类加载阶段之后，除了在加载阶段可以自定义类加载器以外，其它操作都由JVM主导。到了初始阶段，才开始真正执行类中定义的Java程序代码。            
### 12.类加载器
> 虚拟机设计团队把加载动作放到JVM外部实现，以便让应用程序决定如何获取所需的类，JVM提供了3种类加载器：                      
> 启动类加载器(Bootstrap ClassLoader)                                           
> 负责加载JAVA_HOME\lib目录中的，或通过-Xbootclasspath参数指定路径中的，且被虚拟机认可（按文件名识别，如 rt.jar）的类。              
> 扩展类加载器(Extension ClassLoader)                          
> 负责加载JAVA_HOME\lib\ext目录中的，或通过 java.ext.dirs系统变量指定路径中的类库。              
> 应用程序类加载器(Application ClassLoader)：                    
> 负责加载用户路径（classpath）上的类库。                            
> JVM通过双亲委派模型进行类的加载，当然也可以通过继承java.lang.ClassLoader实现自定义的类加载器。       
> ![classloader2](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/classloader2.png)                                                  
### 13.双亲委派模型
> 当一个类收到了类加载请求，它首先不会尝试自己去加载这个类，而是把这个请求委派给父类去完成，每一个层次类加载器都是如此，
> 因此所有的加载请求都应该传送到启动类加载其中，只有当父类加载器反馈自己无法完成这个请求的时候（在它的加载路径下没有找到所需加载的Class），
> 子类加载器才会尝试自己去加载。                   
> 采用双亲委派的一个好处是比如加载位于rt.jar包中的类java.lang.Object，不管是哪个加载器加载这个类，最终都是委托给顶层的启动类加载器进行加载，
> 这样就保证了使用不同的类加载器最终得到的都是同样一个Object对象。         
### 14.Student s=new Student();在内存中做了哪些事情?
>加载Student.class文件进內存，如果该类有父类，要先加载其父类               
 在虚拟机栈中为引用变量s开辟空间(栈中不会默认初始化)                    
 在堆內存中为学生对象开辟空间，进行默认初始化(0,null)             
 如果Student有父类，则进行父类属性的初始化化(代码块和定义属性时的赋值，哪个写在前面就先执行哪个)           
 如果Student有父类，则进行父类构造函数的初始化             
 Student属性的初始化                      
 Student构造函数的初始化                    
 对象构造完毕，把地址赋值给s变量 
### 15.JVM的主要组成部分？及其作用？
>类加载器（ClassLoader）                  
 运行时数据区（Runtime Data Area）                  
 执行引擎（Execution Engine）                     
 本地库接口（Native Interface）            
>组件的作用:首先通过类加载器（ClassLoader）会把Java代码转换成字节码，运行时数据区（Runtime Data Area）再把字节码加载到内存中，
>而字节码文件只是JVM的一套指令集规范，并不能直接交个底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine）将字节码翻译成底层系统指令再交由CPU去执行，
>而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能。                      
> ![jvm_component](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/jvm_component.png)                                                  
### 16.jvm中堆栈的区别？
>(1).栈内存存储的是局部变量,堆内存存储的是对象实例；               
 (2).栈内存的更新速度要快于堆内存，因为局部变量的生命周期很短；                  
 (3).栈内存存放的变量生命周期一旦结束就会被释放，而堆内存存放的实体会被垃圾回收机制不定时的回收;                             
 (4).栈内存是线程私有的;堆内存是线程共享的。   
### 17.简述分代垃圾回收器是怎么工作的？
>分代回收器有两个分区：新生代和老年代，新生代默认的空间占比总空间的 1/3，老年代的默认占比是 2/3。                         
 新生代使用的是复制算法，新生代里有3个分区：Eden、To Survivor、From Survivor，它们的默认占比是 8:1:1，它的执行流程如下：                    
 把Eden + From Survivor存活的对象放入To Survivor 区；                                  
 清空Eden和From Survivor分区；                
 From Survivor和 To Survivor分区交换，From Survivor变To Survivor，To Survivor变From Survivor。                
 每次在From Survivor到To Survivor移动时都存活的对象，年龄就+1，当年龄到达15（默认配置是15）时，升级为老年代。大对象也会直接进入老生代。             
 老年代当空间占用到达某个值之后就会触发全局垃圾收回，一般使用标记整理算法。以上这些循环往复就构成了整个分代垃圾回收的整体执行流程。
### 18.jvm调优的工具？
>JDK自带了很多监控工具，都位于JDK的bin目录下，其中最常用的是jconsole和jvisualvm这两款视图监控工具。         
 jconsole用于对JVM中的内存、线程和类等进行监控；              
 jvisualvm是JDK自带的全能分析工具，可以分析内存快照、线程快照、程序死锁、监控内存的变化、gc变化等。           
### 19.常用的jvm调优的参数都有哪些？
>-Xms2g：初始化推大小为 2g；                      
 -Xmx2g：堆最大内存为 2g；              
 -XX:NewRatio=4：设置年轻的和老年代的内存比例为 1:4；                    
 -XX:SurvivorRatio=8：设置新生代 Eden 和 Survivor 比例为 8:2；                 
 –XX:+UseParNewGC：指定使用 ParNew + Serial Old 垃圾回收器组合；             
 -XX:+UseParallelOldGC：指定使用 ParNew + ParNew Old 垃圾回收器组合；                
 -XX:+UseConcMarkSweepGC：指定使用 CMS + Serial Old 垃圾回收器组合；             
 -XX:+PrintGC：开启打印 gc 信息；           
 -XX:+PrintGCDetails：打印 gc 详细信息。
### 20.java中的内存泄露和内存溢出？
>Java内存泄露与溢出的区别:                        
 Java内存泄漏是没有及时清理内存垃圾，导致系统无法再提供内存资源（内存资源耗尽）                      
 Java内存溢出是要求分配的内存超出了系统能给的，系统不能满足需求，于是产生溢出。                                  
 一次内存泄漏似乎不会有大的影响，但内存泄漏堆积后的后果就是内存溢出。                                 
 (1).静态集合类:如HashMap、LinkedList等等。如果这些容器为静态的，那么它们的生命周期与程序一致，则容器中的对象在程序结束之前将不能被释放，
>从而造成内存泄漏。简单而言，长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用，但是因为长生命周期对象持有它的引用而导致不能被回收。                       
 (2).物理链接:如数据库连接、网络连接和IO连接等。在对数据库进行操作的过程中，首先需要建立与数据库的连接，当不再使用时，需要调用close方法来释放与数据库的连接。                   
>只有连接被关闭后，垃圾回收器才会回收对应的对象。否则，如果在访问数据库的过程中，对Connection、Statement或ResultSet不显性地关闭，将会造成大量的对象无法被回收，从而引起内存泄漏。                                  
 (3).改变哈希值:当一个对象被存储进HashSet集合中以后，就不能修改这个对象中的那些参与计算哈希值的字段了，否则，对象修改后的哈希值与最初存储进
>HashSet集合中时的哈希值就不同了，在这种情况下，即使在contains方法使用该对象的当前引用作为的参数去HashSet集合中检索对象，也将返回找不到对
>象的结果，这也会导致无法从HashSet集合中单独删除当前对象，造成内存泄露                 
 (4).内部类持有外部类:如果一个外部类的实例对象的方法返回了一个内部类的实例对象，这个内部类对象被长期引用了，即使那个外部类实例对象不再被使用，
>但由于内部类持有外部类的实例对象，这个外部类对象将不会被垃圾回收，这也会造成内存泄露。                    
 (5).变量不合理的作用域:一个变量定义的作用范围大于其使用范围，很有可能会造成内存泄漏。
>另一方面，如果没有及时地把对象设置为null，很有可能导致内存泄漏的发生。                      
 (6).单例模式:因为单例对象的初始化将在JVM的整个生命周期内存在，如果它持有一个外部对象的(生命周期比较短)引用，那么这个外部对象就不能被回收，
>从而导致内存泄露。如果这个外部对象还持有其他对象的引用，那么内存泄露更严重。                                                                                         
                                            
### 参考 https://blog.csdn.net/qq_41701956/article/details/81664921