java虚拟机JVM
======
## 问题列表
### 1.Java虚拟机运行时数据区域
## 问题答案
### 1.Java虚拟机运行时数据区域
> ![java_run_data_area](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/java_run_data_area.png)                                               
> (1).方法区:属于共享内存区域，存储被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。                 
> (2).堆:对于绝大多数应用来说，这块区域是JVM所管理的内存中最大的一块。线程共享，主要是存放对象实例和数组。内部会划分出多个线程私有的分配缓冲区(Thread Local Allocation Buffer, TLAB)。可以位于物理上不连续的空间，但是逻辑上要连续。                                  
  OutOfMemoryError:如果堆中没有内存完成实例分配，并且堆也无法再扩展时，抛出该异常。                 
> (3).Java虚拟机栈:线程私有，生命周期和线程一致。描述的是 Java 方法执行的内存模型：每个方法在执行时都会床创建一个栈帧(Stack Frame)用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程。                  
  局部变量表:存放了编译期可知的各种基本类型(boolean、byte、char、short、int、float、long、double)、对象引用(reference 类型)和 returnAddress 类型(指向了一条字节码指令的地址)                  
  StackOverflowError：线程请求的栈深度大于虚拟机所允许的深度。                       
  OutOfMemoryError：如果虚拟机栈可以动态扩展，而扩展时无法申请到足够的内存。                 
  (4).本地方法栈:区别于Java虚拟机栈的是，Java虚拟机栈为虚拟机执行Java方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的Native方法服务。也会有StackOverflowError和OutOfMemoryError异常。                
  (5).程序计数器:内存空间小，线程私有。字节码解释器工作是就是通过改变这个计数器的值来选取下一条需要执行指令的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器完成。                                    
  如果线程正在执行一个Java方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Native方法，这个计数器的值则为(Undefined)。
> 此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。                                          
> ![java_run_data_area2](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/java_run_data_area2.png)                                              
> (6).运行时常量池:属于方法区一部分，用于存放编译期生成的各种字面量和符号引用。编译器和运行期(String 的 intern() )都可以将常量放入池中。内存有限，无法申请时抛出 OutOfMemoryError。                 
  (7).直接内存:非虚拟机运行时数据区的部分                        
  在JDK1.4中新加入NIO(New Input/Output)类，引入了一种基于通道(Channel)和缓存(Buffer)的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。可以避免在Java堆和Native 堆中来回的数据耗时操作。
  OutOfMemoryError：会受到本机内存限制，如果内存区域总和大于物理内存限制从而导致动态扩展时出现该异常。                                                                                    
### 2.对象是如何创建、如何布局以及如何访问的？
> (1).对象的创建             
> 在语言层面上，对象的创建常见方式是new关键字进行创建(还可以通过反射、反序列化、克隆创建)，在jvm内部，jvm碰到new指令以后在内部是如何操作的？                  
  jvm碰到new指令执行流程:                   
  [1].检查指令参数能否在方法区常量池中定位到一个符号引用。如果无法定位到一个符号引用，说明这个类没有定义，将抛出ClassNotFoundException                   
  [2].检查这个符号引用所对应的类有没有被加载，解析和初始化。如果没有，需要执行加载过程。                 
  [3].在类已被加载，解析、初始化以后，需要在堆中为新生对象分配内存。对象在类加载以后，由类生产的对象大小即可确定。                    
  在堆中分配对象空间的方法有指针碰撞法和空闲列表法。对象采用何种分配算法，取决于jvm采用何种垃圾回收算法，标记清除算法适合采用空闲列表，而标记整理，复制算法适合于指针碰撞法。                   
  指针碰撞法：java堆属于规整状态，已用堆内存在一侧，空闲堆内存在另一侧，中间通过指针分割并划分内存，当有新生对象到来时，通过移动指针给新生对象划分特定大小的内存。                    
  这种方法要求java堆必须处于规整状态。                  
  空闲列表法：堆内存可以不规整，此时需要通过一个空闲列表记录在堆内存中存在的空间空间。当有新生代对象到来时，通过查看空闲列表，找到适合对象大小的内存空间，将空间分配给该对象，并修改空闲列表。                
  这种方法需要划出额外的空间用于维护空闲列表。                    
  [4].为对象中的成员变量赋上默认初始值                  
  [5].设置对象头信息，对象是属于哪个类的实例，对象的哈希码，对象的GC分代年龄等             
  [6].调用对象的构造函数进行初始化。           
> (2).对象在内存中的布局             
  在hotspot虚拟机中，对象在内存中的布局分为三个部分:对象头(Header)、实例数据(Instance Data)和对齐填充(Padding)。           
  对象头               
  存储对象在运行中需要用到的数据：哈希码、GC分代年龄、锁状态标志、线程持有的锁、线程偏向ID、偏向时间戳等；                
  类型指针：对象指向其类元数据的指针，虚拟机通过这个指针确定这个对象是哪个类的实例；             
  如果对象是数组，对象头中还有一块区域用于保存数组大小；               
  实例数据              
  存放的是对象各种类型字段的值，包括父类成员变量，子类成员变量            
  对齐填充          
  hotspot jvm要求对象起始地址必须是8字节的整数倍，所以要保证一个对象所占的内存是8的整数倍，由于对象头正好是8的整数倍，所以通过填充实例数据使其成为8字节的整数倍，使对象对齐。             
  (3).对象的访问定位                   
  使用对象时，通过栈上的reference数据来操作堆上的具体对象。                 
  在jvm中有2种对象定位方式，一种是句柄访问，一种是直接地址访问。             
  句柄访问                  
  java堆中划分出一块内存作为句柄池，虚拟机栈中存储的是对象的句柄地址，句柄中包含了对象的实例地址和元数据地址。访问对象时，先根据对象引用找到句柄池地址，再根据句柄池中的对象数据地址找到对象。              
> ![object_ref1](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/object_ref1.png)                                                           
> 直接地址访问                
  虚拟机栈中的引用存储的是对象在堆内存中的地址，通过该地址直接定位到对象，不需要经过中间媒介，更加快速，但是在对象的内存结构中需要存储对象的类型指针，用于定位方法区的对象类型。               
> ![object_ref2](http://github.com/xidianlina/practice/raw/master//java_practice/topic/picture/object_ref2.png)                                                     
  比较:使用句柄的最大好处是 reference 中存储的是稳定的句柄地址，在对象移动(GC)是只改变实例数据指针地址，reference 自身不需要修改。             
> 直接指针访问的最大好处是速度快，因为它只需要一次寻址操作,节省了一次指针定位的时间开销。但它在对象内存结构中需要额外存储类型指针。
  如果是对象频繁GC那么句柄方法好，如果是对象频繁访问则直接指针访问好。hotspot采用的对象访问方式就是直接地址访问。                                     
















                                              
> 参考 https://blog.csdn.net/qq_41701956/article/details/81664921